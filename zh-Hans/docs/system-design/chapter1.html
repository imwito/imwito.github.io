<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-system-design/chapter1" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Chapter 1 | My Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://imwito.github.io/zh-Hans/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://imwito.github.io/zh-Hans/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://imwito.github.io/zh-Hans/docs/system-design/chapter1"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Chapter 1 | My Site"><meta data-rh="true" name="description" content="IP"><meta data-rh="true" property="og:description" content="IP"><link data-rh="true" rel="icon" href="/zh-Hans/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://imwito.github.io/zh-Hans/docs/system-design/chapter1"><link data-rh="true" rel="alternate" href="https://imwito.github.io/docs/system-design/chapter1" hreflang="en"><link data-rh="true" rel="alternate" href="https://imwito.github.io/zh-Hans/docs/system-design/chapter1" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://imwito.github.io/docs/system-design/chapter1" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/zh-Hans/blog/rss.xml" title="My Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh-Hans/blog/atom.xml" title="My Site Atom Feed">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/zh-Hans/assets/css/styles.466a89db.css">
<link rel="preload" href="/zh-Hans/assets/js/runtime~main.c214fdea.js" as="script">
<link rel="preload" href="/zh-Hans/assets/js/main.c22237af.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/zh-Hans/"><div class="navbar__logo"><img src="/zh-Hans/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/zh-Hans/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">My Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/zh-Hans/docs/intro">Tutorial</a><a class="navbar__item navbar__link" href="/zh-Hans/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/imwito/imwito.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>简体中文</a><ul class="dropdown__menu"><li><a href="/docs/system-design/chapter1" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">English</a></li><li><a href="/zh-Hans/docs/system-design/chapter1" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-Hans">简体中文</a></li></ul></div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/zh-Hans/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/zh-Hans/docs/category/system-design">System Design</a><button aria-label="打开/收起侧边栏菜单「System Design」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/docs/system-design/intro">Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/zh-Hans/docs/system-design/chapter1">Chapter 1</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/docs/system-design/chapter2">Chapter 2</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/docs/system-design/chapter3">Chapter 3</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/docs/system-design/chapter4">Chapter 4</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/zh-Hans/docs/system-design/chapter5">Chapter 5</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/zh-Hans/docs/category/tutorial---basics">Tutorial - Basics</a><button aria-label="打开/收起侧边栏菜单「Tutorial - Basics」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/zh-Hans/docs/category/tutorial---extras">Tutorial - Extras</a><button aria-label="打开/收起侧边栏菜单「Tutorial - Extras」" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/zh-Hans/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/zh-Hans/docs/category/system-design"><span itemprop="name">System Design</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Chapter 1</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>Chapter 1</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="ip">IP<a href="#ip" class="hash-link" aria-label="IP的直接链接" title="IP的直接链接">​</a></h2><p>An IP address is a unique address that identifies a device on the internet or a local network. IP stands for <em>&quot;Internet Protocol&quot;</em>, which is the set of rules governing the format of data sent via the internet or local network.</p><p>In essence, IP addresses are the identifier that allows information to be sent between devices on a network. They contain location information and make devices accessible for communication. The internet needs a way to differentiate between different computers, routers, and websites. IP addresses provide a way of doing so and form an essential part of how the internet works.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="versions">Versions<a href="#versions" class="hash-link" aria-label="Versions的直接链接" title="Versions的直接链接">​</a></h3><p>Now, let&#x27;s learn about the different versions of IP addresses:</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="ipv4">IPv4<a href="#ipv4" class="hash-link" aria-label="IPv4的直接链接" title="IPv4的直接链接">​</a></h4><p>The original Internet Protocol is IPv4 which uses a 32-bit numeric dot-decimal notation that only allows for around 4 billion IP addresses. Initially, it was more than enough but as internet adoption grew, we needed something better.</p><p><em>Example: <code>102.22.192.181</code></em></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="ipv6">IPv6<a href="#ipv6" class="hash-link" aria-label="IPv6的直接链接" title="IPv6的直接链接">​</a></h4><p>IPv6 is a new protocol that was introduced in 1998. Deployment commenced in the mid-2000s and since the internet users have grown exponentially, it is still ongoing.</p><p>This new protocol uses 128-bit alphanumeric hexadecimal notation. This means that IPv6 can provide about ~340e+36 IP addresses. That&#x27;s more than enough to meet the growing demand for years to come.</p><p><em>Example: <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code></em></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="types">Types<a href="#types" class="hash-link" aria-label="Types的直接链接" title="Types的直接链接">​</a></h3><p>Let&#x27;s discuss types of IP addresses:</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="public">Public<a href="#public" class="hash-link" aria-label="Public的直接链接" title="Public的直接链接">​</a></h4><p>A public IP address is an address where one primary address is associated with your whole network. In this type of IP address, each of the connected devices has the same IP address.</p><p><em>Example: IP address provided to your router by the ISP.</em></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="private">Private<a href="#private" class="hash-link" aria-label="Private的直接链接" title="Private的直接链接">​</a></h4><p>A private IP address is a unique IP number assigned to every device that connects to your internet network, which includes devices like computers, tablets, and smartphones, which are used in your household.</p><p><em>Example: IP addresses generated by your home router for your devices.</em></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="static">Static<a href="#static" class="hash-link" aria-label="Static的直接链接" title="Static的直接链接">​</a></h4><p>A static IP address does not change and is one that was manually created, as opposed to having been assigned. These addresses are usually more expensive but are more reliable.</p><p><em>Example: They are usually used for important things like reliable geo-location services, remote access, server hosting, etc.</em></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="dynamic">Dynamic<a href="#dynamic" class="hash-link" aria-label="Dynamic的直接链接" title="Dynamic的直接链接">​</a></h4><p>A dynamic IP address changes from time to time and is not always the same. It has been assigned by a <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener noreferrer">Dynamic Host Configuration Protocol (DHCP)</a> server. Dynamic IP addresses are the most common type of internet protocol address. They are cheaper to deploy and allow us to reuse IP addresses within a network as needed.</p><p><em>Example: They are more commonly used for consumer equipment and personal use.</em></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="osi-model">OSI Model<a href="#osi-model" class="hash-link" aria-label="OSI Model的直接链接" title="OSI Model的直接链接">​</a></h2><p>The OSI Model is a logical and conceptual model that defines network communication used by systems open to interconnection and communication with other systems. The Open System Interconnection (OSI Model) also defines a logical network and effectively describes computer packet transfer by using various layers of protocols.</p><p>The OSI Model can be seen as a universal language for computer networking. It&#x27;s based on the concept of splitting up a communication system into seven abstract layers, each one stacked upon the last.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="why-does-the-osi-model-matter">Why does the OSI model matter?<a href="#why-does-the-osi-model-matter" class="hash-link" aria-label="Why does the OSI model matter?的直接链接" title="Why does the OSI model matter?的直接链接">​</a></h3><p>The Open System Interconnection (OSI) model has defined the common terminology used in networking discussions and documentation. This allows us to take a very complex communications process apart and evaluate its components.</p><p>While this model is not directly implemented in the TCP/IP networks that are most common today, it can still help us do so much more, such as:</p><ul><li>Make troubleshooting easier and help identify threats across the entire stack.</li><li>Encourage hardware manufacturers to create networking products that can communicate with each other over the network.</li><li>Essential for developing a security-first mindset.</li><li>Separate a complex function into simpler components.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="layers">Layers<a href="#layers" class="hash-link" aria-label="Layers的直接链接" title="Layers的直接链接">​</a></h3><p>The seven abstraction layers of the OSI model can be defined as follows, from top to bottom:</p><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/osi-model/osi-model.png" alt="osi-model" class="img_ev3q"></p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="application">Application<a href="#application" class="hash-link" aria-label="Application的直接链接" title="Application的直接链接">​</a></h4><p>This is the only layer that directly interacts with data from the user. Software applications like web browsers and email clients rely on the application layer to initiate communication. But it should be made clear that client software applications are not part of the application layer, rather the application layer is responsible for the protocols and data manipulation that the software relies on to present meaningful data to the user. Application layer protocols include HTTP as well as SMTP.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="presentation">Presentation<a href="#presentation" class="hash-link" aria-label="Presentation的直接链接" title="Presentation的直接链接">​</a></h4><p>The presentation layer is also called the Translation layer. The data from the application layer is extracted here and manipulated as per the required format to transmit over the network. The functions of the presentation layer are translation, encryption/decryption, and compression.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="session">Session<a href="#session" class="hash-link" aria-label="Session的直接链接" title="Session的直接链接">​</a></h4><p>This is the layer responsible for opening and closing communication between the two devices. The time between when the communication is opened and closed is known as the session. The session layer ensures that the session stays open long enough to transfer all the data being exchanged, and then promptly closes the session in order to avoid wasting resources. The session layer also synchronizes data transfer with checkpoints.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="transport">Transport<a href="#transport" class="hash-link" aria-label="Transport的直接链接" title="Transport的直接链接">​</a></h4><p>The transport layer (also known as layer 4) is responsible for end-to-end communication between the two devices. This includes taking data from the session layer and breaking it up into chunks called segments before sending it to the Network layer (layer 3). It is also responsible for reassembling the segments on the receiving device into data the session layer can consume.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="network">Network<a href="#network" class="hash-link" aria-label="Network的直接链接" title="Network的直接链接">​</a></h4><p>The network layer is responsible for facilitating data transfer between two different networks. The network layer breaks up segments from the transport layer into smaller units, called packets, on the sender&#x27;s device, and reassembles these packets on the receiving device. The network layer also finds the best physical path for the data to reach its destination this is known as routing. If the two devices communicating are on the same network, then the network layer is unnecessary.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="data-link">Data Link<a href="#data-link" class="hash-link" aria-label="Data Link的直接链接" title="Data Link的直接链接">​</a></h4><p>The data link layer is very similar to the network layer, except the data link layer facilitates data transfer between two devices on the same network. The data link layer takes packets from the network layer and breaks them into smaller pieces called frames.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="physical">Physical<a href="#physical" class="hash-link" aria-label="Physical的直接链接" title="Physical的直接链接">​</a></h4><p>This layer includes the physical equipment involved in the data transfer, such as the cables and switches. This is also the layer where the data gets converted into a bit stream, which is a string of 1s and 0s. The physical layer of both devices must also agree on a signal convention so that the 1s can be distinguished from the 0s on both devices.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="tcp-and-udp">TCP and UDP<a href="#tcp-and-udp" class="hash-link" aria-label="TCP and UDP的直接链接" title="TCP and UDP的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tcp">TCP<a href="#tcp" class="hash-link" aria-label="TCP的直接链接" title="TCP的直接链接">​</a></h3><p>Transmission Control Protocol (TCP) is connection-oriented, meaning once a connection has been established, data can be transmitted in both directions. TCP has built-in systems to check for errors and to guarantee data will be delivered in the order it was sent, making it the perfect protocol for transferring information like still images, data files, and web pages.</p><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/tcp-and-udp/tcp.png" alt="tcp" class="img_ev3q"></p><p>But while TCP is instinctively reliable, its feedback mechanisms also result in a larger overhead, translating to greater use of the available bandwidth on the network.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="udp">UDP<a href="#udp" class="hash-link" aria-label="UDP的直接链接" title="UDP的直接链接">​</a></h3><p>User Datagram Protocol (UDP) is a simpler, connectionless internet protocol in which error-checking and recovery services are not required. With UDP, there is no overhead for opening a connection, maintaining a connection, or terminating a connection. Data is continuously sent to the recipient, whether or not they receive it.</p><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/tcp-and-udp/udp.png" alt="udp" class="img_ev3q"></p><p>It is largely preferred for real-time communications like broadcast or multicast network transmission. We should use UDP over TCP when we need the lowest latency and late data is worse than the loss of data.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="tcp-vs-udp">TCP vs UDP<a href="#tcp-vs-udp" class="hash-link" aria-label="TCP vs UDP的直接链接" title="TCP vs UDP的直接链接">​</a></h3><p>TCP is a connection-oriented protocol, whereas UDP is a connectionless protocol. A key difference between TCP and UDP is speed, as TCP is comparatively slower than UDP. Overall, UDP is a much faster, simpler, and more efficient protocol, however, retransmission of lost data packets is only possible with TCP.</p><p>TCP provides ordered delivery of data from user to server (and vice versa), whereas UDP is not dedicated to end-to-end communications, nor does it check the readiness of the receiver.</p><table><thead><tr><th>Feature</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>Connection</td><td>Requires an established connection</td><td>Connectionless protocol</td></tr><tr><td>Guaranteed delivery</td><td>Can guarantee delivery of data</td><td>Cannot guarantee delivery of data</td></tr><tr><td>Re-transmission</td><td>Re-transmission of lost packets is possible</td><td>No re-transmission of lost packets</td></tr><tr><td>Speed</td><td>Slower than UDP</td><td>Faster than TCP</td></tr><tr><td>Broadcasting</td><td>Does not support broadcasting</td><td>Supports broadcasting</td></tr><tr><td>Use cases</td><td>HTTPS, HTTP, SMTP, POP, FTP, etc</td><td>Video streaming, DNS, VoIP, etc</td></tr></tbody></table><h2 class="anchor anchorWithStickyNavbar_LWe7" id="domain-name-system-dns">Domain Name System (DNS)<a href="#domain-name-system-dns" class="hash-link" aria-label="Domain Name System (DNS)的直接链接" title="Domain Name System (DNS)的直接链接">​</a></h2><p>Earlier we learned about IP addresses that enable every machine to connect with other machines. But as we know humans are more comfortable with names than numbers. It&#x27;s easier to remember a name like <code>google.com</code> than something like <code>122.250.192.232</code>.</p><p>This brings us to Domain Name System (DNS) which is a hierarchical and decentralized naming system used for translating human-readable domain names to IP addresses.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="how-dns-works">How DNS works<a href="#how-dns-works" class="hash-link" aria-label="How DNS works的直接链接" title="How DNS works的直接链接">​</a></h3><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/domain-name-system/how-dns-works.png" alt="how-dns-works" class="img_ev3q"></p><p>DNS lookup involves the following eight steps:</p><ol><li>A client types <a href="http://example.com" target="_blank" rel="noopener noreferrer">example.com</a> into a web browser, the query travels to the internet and is received by a DNS resolver.</li><li>The resolver then recursively queries a DNS root nameserver.</li><li>The root server responds to the resolver with the address of a Top-Level Domain (TLD).</li><li>The resolver then makes a request to the <code>.com</code> TLD.</li><li>The TLD server then responds with the IP address of the domain&#x27;s nameserver, <a href="http://example.com" target="_blank" rel="noopener noreferrer">example.com</a>.</li><li>Lastly, the recursive resolver sends a query to the domain&#x27;s nameserver.</li><li>The IP address for <a href="http://example.com" target="_blank" rel="noopener noreferrer">example.com</a> is then returned to the resolver from the nameserver.</li><li>The DNS resolver then responds to the web browser with the IP address of the domain requested initially.</li></ol><p>Once the IP address has been resolved, the client should be able to request content from the resolved IP address. For example, the resolved IP may return a webpage to be rendered in the browser.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="server-types">Server types<a href="#server-types" class="hash-link" aria-label="Server types的直接链接" title="Server types的直接链接">​</a></h3><p>Now, let&#x27;s look at the four key groups of servers that make up the DNS infrastructure.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="dns-resolver">DNS Resolver<a href="#dns-resolver" class="hash-link" aria-label="DNS Resolver的直接链接" title="DNS Resolver的直接链接">​</a></h4><p>A DNS resolver (also known as a DNS recursive resolver) is the first stop in a DNS query. The recursive resolver acts as a middleman between a client and a DNS nameserver. After receiving a DNS query from a web client, a recursive resolver will either respond with cached data, or send a request to a root nameserver, followed by another request to a TLD nameserver, and then one last request to an authoritative nameserver. After receiving a response from the authoritative nameserver containing the requested IP address, the recursive resolver then sends a response to the client.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="dns-root-server">DNS root server<a href="#dns-root-server" class="hash-link" aria-label="DNS root server的直接链接" title="DNS root server的直接链接">​</a></h4><p>A root server accepts a recursive resolver&#x27;s query which includes a domain name, and the root nameserver responds by directing the recursive resolver to a TLD nameserver, based on the extension of that domain (<code>.com</code>, <code>.net</code>, <code>.org</code>, etc.). The root nameservers are overseen by a nonprofit called the <a href="https://www.icann.org" target="_blank" rel="noopener noreferrer">Internet Corporation for Assigned Names and Numbers (ICANN)</a>.</p><p>There are 13 DNS root nameservers known to every recursive resolver. Note that while there are 13 root nameservers, that doesn&#x27;t mean that there are only 13 machines in the root nameserver system. There are 13 types of root nameservers, but there are multiple copies of each one all over the world, which use <a href="https://en.wikipedia.org/wiki/Anycast" target="_blank" rel="noopener noreferrer">Anycast routing</a> to provide speedy responses.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="tld-nameserver">TLD nameserver<a href="#tld-nameserver" class="hash-link" aria-label="TLD nameserver的直接链接" title="TLD nameserver的直接链接">​</a></h4><p>A TLD nameserver maintains information for all the domain names that share a common domain extension, such as <code>.com</code>, <code>.net</code>, or whatever comes after the last dot in a URL.</p><p>Management of TLD nameservers is handled by the <a href="https://www.iana.org" target="_blank" rel="noopener noreferrer">Internet Assigned Numbers Authority (IANA)</a>, which is a branch of <a href="https://www.icann.org" target="_blank" rel="noopener noreferrer">ICANN</a>. The IANA breaks up the TLD servers into two main groups:</p><ul><li><strong>Generic top-level domains</strong>: These are domains like <code>.com</code>, <code>.org</code>, <code>.net</code>, <code>.edu</code>, and <code>.gov</code>.</li><li><strong>Country code top-level domains</strong>: These include any domains that are specific to a country or state. Examples include <code>.uk</code>, <code>.us</code>, <code>.ru</code>, and <code>.jp</code>.</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="authoritative-dns-server">Authoritative DNS server<a href="#authoritative-dns-server" class="hash-link" aria-label="Authoritative DNS server的直接链接" title="Authoritative DNS server的直接链接">​</a></h4><p>The authoritative nameserver is usually the resolver&#x27;s last step in the journey for an IP address. The authoritative nameserver contains information specific to the domain name it serves (e.g. <a href="http://google.com" target="_blank" rel="noopener noreferrer">google.com</a>) and it can provide a recursive resolver with the IP address of that server found in the DNS A record, or if the domain has a CNAME record (alias) it will provide the recursive resolver with an alias domain, at which point the recursive resolver will have to perform a whole new DNS lookup to procure a record from an authoritative nameserver (often an A record containing an IP address). If it cannot find the domain, returns the NXDOMAIN message.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="query-types">Query Types<a href="#query-types" class="hash-link" aria-label="Query Types的直接链接" title="Query Types的直接链接">​</a></h3><p>There are three types of queries in a DNS system:</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="recursive">Recursive<a href="#recursive" class="hash-link" aria-label="Recursive的直接链接" title="Recursive的直接链接">​</a></h4><p>In a recursive query, a DNS client requires that a DNS server (typically a DNS recursive resolver) will respond to the client with either the requested resource record or an error message if the resolver can&#x27;t find the record.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="iterative">Iterative<a href="#iterative" class="hash-link" aria-label="Iterative的直接链接" title="Iterative的直接链接">​</a></h4><p>In an iterative query, a DNS client provides a hostname, and the DNS Resolver returns the best answer it can. If the DNS resolver has the relevant DNS records in its cache, it returns them. If not, it refers the DNS client to the Root Server or another Authoritative Name Server that is nearest to the required DNS zone. The DNS client must then repeat the query directly against the DNS server it was referred.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="non-recursive">Non-recursive<a href="#non-recursive" class="hash-link" aria-label="Non-recursive的直接链接" title="Non-recursive的直接链接">​</a></h4><p>A non-recursive query is a query in which the DNS Resolver already knows the answer. It either immediately returns a DNS record because it already stores it in a local cache, or queries a DNS Name Server which is authoritative for the record, meaning it definitely holds the correct IP for that hostname. In both cases, there is no need for additional rounds of queries (like in recursive or iterative queries). Rather, a response is immediately returned to the client.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="record-types">Record Types<a href="#record-types" class="hash-link" aria-label="Record Types的直接链接" title="Record Types的直接链接">​</a></h3><p>DNS records (aka zone files) are instructions that live in authoritative DNS servers and provide information about a domain including what IP address is associated with that domain and how to handle requests for that domain.</p><p>These records consist of a series of text files written in what is known as <em>DNS syntax</em>. DNS syntax is just a string of characters used as commands that tell the DNS server what to do. All DNS records also have a <em>&quot;TTL&quot;</em>, which stands for time-to-live, and indicates how often a DNS server will refresh that record.</p><p>There are more record types but for now, let&#x27;s look at some of the most commonly used ones:</p><ul><li><strong>A (Address record)</strong>: This is the record that holds the IP address of a domain.</li><li><strong>AAAA (IP Version 6 Address record)</strong>: The record that contains the IPv6 address for a domain (as opposed to A records, which stores the IPv4 address).</li><li><strong>CNAME (Canonical Name record)</strong>: Forwards one domain or subdomain to another domain, does NOT provide an IP address.</li><li><strong>MX (Mail exchanger record)</strong>: Directs mail to an email server.</li><li><strong>TXT (Text Record)</strong>: This record lets an admin store text notes in the record. These records are often used for email security.</li><li><strong>NS (Name Server records)</strong>: Stores the name server for a DNS entry.</li><li><strong>SOA (Start of Authority)</strong>: Stores admin information about a domain.</li><li><strong>SRV (Service Location record)</strong>: Specifies a port for specific services.</li><li><strong>PTR (Reverse-lookup Pointer records)</strong>: Provides a domain name in reverse lookups.</li><li><strong>CERT (Certificate record)</strong>: Stores public key certificates.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="subdomains">Subdomains<a href="#subdomains" class="hash-link" aria-label="Subdomains的直接链接" title="Subdomains的直接链接">​</a></h3><p>A subdomain is an additional part of our main domain name. It is commonly used to logically separate a website into sections. We can create multiple subdomains or child domains on the main domain.</p><p>For example, <code>blog.example.com</code> where <code>blog</code> is the subdomain, <code>example</code> is the primary domain and <code>.com</code> is the top-level domain (TLD). Similar examples can be <code>support.example.com</code> or <code>careers.example.com</code>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dns-zones">DNS Zones<a href="#dns-zones" class="hash-link" aria-label="DNS Zones的直接链接" title="DNS Zones的直接链接">​</a></h3><p>A DNS zone is a distinct part of the domain namespace which is delegated to a legal entity like a person, organization, or company, who is responsible for maintaining the DNS zone. A DNS zone is also an administrative function, allowing for granular control of DNS components, such as authoritative name servers.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dns-caching">DNS Caching<a href="#dns-caching" class="hash-link" aria-label="DNS Caching的直接链接" title="DNS Caching的直接链接">​</a></h3><p>A DNS cache (sometimes called a DNS resolver cache) is a temporary database, maintained by a computer&#x27;s operating system, that contains records of all the recent visits and attempted visits to websites and other internet domains. In other words, a DNS cache is just a memory of recent DNS lookups that our computer can quickly refer to when it&#x27;s trying to figure out how to load a website.</p><p>The Domain Name System implements a time-to-live (TTL) on every DNS record. TTL specifies the number of seconds the record can be cached by a DNS client or server. When the record is stored in a cache, whatever TTL value came with it gets stored as well. The server continues to update the TTL of the record stored in the cache, counting down every second. When it hits zero, the record is deleted or purged from the cache. At that point, if a query for that record is received, the DNS server has to start the resolution process.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="reverse-dns">Reverse DNS<a href="#reverse-dns" class="hash-link" aria-label="Reverse DNS的直接链接" title="Reverse DNS的直接链接">​</a></h3><p>A reverse DNS lookup is a DNS query for the domain name associated with a given IP address. This accomplishes the opposite of the more commonly used forward DNS lookup, in which the DNS system is queried to return an IP address. The process of reverse resolving an IP address uses PTR records. If the server does not have a PTR record, it cannot resolve a reverse lookup.</p><p>Reverse lookups are commonly used by email servers. Email servers check and see if an email message came from a valid server before bringing it onto their network. Many email servers will reject messages from any server that does not support reverse lookups or from a server that is highly unlikely to be legitimate.</p><p><em>Note: Reverse DNS lookups are not universally adopted as they are not critical to the normal function of the internet.</em></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="examples">Examples<a href="#examples" class="hash-link" aria-label="Examples的直接链接" title="Examples的直接链接">​</a></h3><p>These are some widely used managed DNS solutions:</p><ul><li><a href="https://aws.amazon.com/route53" target="_blank" rel="noopener noreferrer">Route53</a></li><li><a href="https://www.cloudflare.com/dns" target="_blank" rel="noopener noreferrer">Cloudflare DNS</a></li><li><a href="https://cloud.google.com/dns" target="_blank" rel="noopener noreferrer">Google Cloud DNS</a></li><li><a href="https://azure.microsoft.com/en-in/services/dns" target="_blank" rel="noopener noreferrer">Azure DNS</a></li><li><a href="https://ns1.com/products/managed-dns" target="_blank" rel="noopener noreferrer">NS1</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="load-balancing">Load Balancing<a href="#load-balancing" class="hash-link" aria-label="Load Balancing的直接链接" title="Load Balancing的直接链接">​</a></h2><p>Load balancing lets us distribute incoming network traffic across multiple resources ensuring high availability and reliability by sending requests only to resources that are online. This provides the flexibility to add or subtract resources as demand dictates.</p><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/load-balancing/load-balancer.png" alt="load-balancing" class="img_ev3q"></p><p>For additional scalability and redundancy, we can try to load balance at each layer of our system:</p><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/load-balancing/load-balancer-layers.png" alt="load-balancing-layers" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="but-why">But why?<a href="#but-why" class="hash-link" aria-label="But why?的直接链接" title="But why?的直接链接">​</a></h3><p>Modern high-traffic websites must serve hundreds of thousands, if not millions, of concurrent requests from users or clients. To cost-effectively scale to meet these high volumes, modern computing best practice generally requires adding more servers.</p><p>A load balancer can sit in front of the servers and route client requests across all servers capable of fulfilling those requests in a manner that maximizes speed and capacity utilization. This ensures that no single server is overworked, which could degrade performance. If a single server goes down, the load balancer redirects traffic to the remaining online servers. When a new server is added to the server group, the load balancer automatically starts sending requests to it.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="workload-distribution">Workload distribution<a href="#workload-distribution" class="hash-link" aria-label="Workload distribution的直接链接" title="Workload distribution的直接链接">​</a></h3><p>This is the core functionality provided by a load balancer and has several common variations:</p><ul><li><strong>Host-based</strong>: Distributes requests based on the requested hostname.</li><li><strong>Path-based</strong>: Using the entire URL to distribute requests as opposed to just the hostname.</li><li><strong>Content-based</strong>: Inspects the message content of a request. This allows distribution based on content such as the value of a parameter.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="layers-1">Layers<a href="#layers-1" class="hash-link" aria-label="Layers的直接链接" title="Layers的直接链接">​</a></h3><p>Generally speaking, load balancers operate at one of the two levels:</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="network-layer">Network layer<a href="#network-layer" class="hash-link" aria-label="Network layer的直接链接" title="Network layer的直接链接">​</a></h4><p>This is the load balancer that works at the network&#x27;s transport layer, also known as layer 4. This performs routing based on networking information such as IP addresses and is not able to perform content-based routing. These are often dedicated hardware devices that can operate at high speed.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="application-layer">Application layer<a href="#application-layer" class="hash-link" aria-label="Application layer的直接链接" title="Application layer的直接链接">​</a></h4><p>This is the load balancer that operates at the application layer, also known as layer 7. Load balancers can read requests in their entirety and perform content-based routing. This allows the management of load based on a full understanding of traffic.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="types-1">Types<a href="#types-1" class="hash-link" aria-label="Types的直接链接" title="Types的直接链接">​</a></h3><p>Let&#x27;s look at different types of load balancers:</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="software">Software<a href="#software" class="hash-link" aria-label="Software的直接链接" title="Software的直接链接">​</a></h4><p>Software load balancers usually are easier to deploy than hardware versions. They also tend to be more cost-effective and flexible, and they are used in conjunction with software development environments. The software approach gives us the flexibility of configuring the load balancer to our environment&#x27;s specific needs. The boost in flexibility may come at the cost of having to do more work to set up the load balancer. Compared to hardware versions, which offer more of a closed-box approach, software balancers give us more freedom to make changes and upgrades.</p><p>Software load balancers are widely used and are available either as installable solutions that require configuration and management or as a managed cloud service.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="hardware">Hardware<a href="#hardware" class="hash-link" aria-label="Hardware的直接链接" title="Hardware的直接链接">​</a></h4><p>As the name implies, a hardware load balancer relies on physical, on-premises hardware to distribute application and network traffic. These devices can handle a large volume of traffic but often carry a hefty price tag and are fairly limited in terms of flexibility.</p><p>Hardware load balancers include proprietary firmware that requires maintenance and updates as new versions, and security patches are released.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="dns">DNS<a href="#dns" class="hash-link" aria-label="DNS的直接链接" title="DNS的直接链接">​</a></h4><p>DNS load balancing is the practice of configuring a domain in the Domain Name System (DNS) such that client requests to the domain are distributed across a group of server machines.</p><p>Unfortunately, DNS load balancing has inherent problems limiting its reliability and efficiency. Most significantly, DNS does not check for server and network outages, or errors. It always returns the same set of IP addresses for a domain even if servers are down or inaccessible.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="routing-algorithms">Routing Algorithms<a href="#routing-algorithms" class="hash-link" aria-label="Routing Algorithms的直接链接" title="Routing Algorithms的直接链接">​</a></h3><p>Now, let&#x27;s discuss commonly used routing algorithms:</p><ul><li><strong>Round-robin</strong>: Requests are distributed to application servers in rotation.</li><li><strong>Weighted Round-robin</strong>: Builds on the simple Round-robin technique to account for differing server characteristics such as compute and traffic handling capacity using weights that can be assigned via DNS records by the administrator.</li><li><strong>Least Connections</strong>: A new request is sent to the server with the fewest current connections to clients. The relative computing capacity of each server is factored into determining which one has the least connections.</li><li><strong>Least Response Time</strong>: Sends requests to the server selected by a formula that combines the fastest response time and fewest active connections.</li><li><strong>Least Bandwidth</strong>: This method measures traffic in megabits per second (Mbps), sending client requests to the server with the least Mbps of traffic.</li><li><strong>Hashing</strong>: Distributes requests based on a key we define, such as the client IP address or the request URL.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="advantages">Advantages<a href="#advantages" class="hash-link" aria-label="Advantages的直接链接" title="Advantages的直接链接">​</a></h3><p>Load balancing also plays a key role in preventing downtime, other advantages of load balancing include the following:</p><ul><li>Scalability</li><li>Redundancy</li><li>Flexibility</li><li>Efficiency</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="redundant-load-balancers">Redundant load balancers<a href="#redundant-load-balancers" class="hash-link" aria-label="Redundant load balancers的直接链接" title="Redundant load balancers的直接链接">​</a></h3><p>As you must&#x27;ve already guessed, the load balancer itself can be a single point of failure. To overcome this, a second or <code>N</code> number of load balancers can be used in a cluster mode.</p><p>And, if there&#x27;s a failure detection and the <em>active</em> load balancer fails, another <em>passive</em> load balancer can take over which will make our system more fault-tolerant.</p><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/load-balancing/redundant-load-balancer.png" alt="redundant-load-balancing" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="features">Features<a href="#features" class="hash-link" aria-label="Features的直接链接" title="Features的直接链接">​</a></h3><p>Here are some commonly desired features of load balancers:</p><ul><li><strong>Autoscaling</strong>: Starting up and shutting down resources in response to demand conditions.</li><li><strong>Sticky sessions</strong>: The ability to assign the same user or device to the same resource in order to maintain the session state on the resource.</li><li><strong>Healthchecks</strong>: The ability to determine if a resource is down or performing poorly in order to remove the resource from the load balancing pool.</li><li><strong>Persistence connections</strong>: Allowing a server to open a persistent connection with a client such as a WebSocket.</li><li><strong>Encryption</strong>: Handling encrypted connections such as TLS and SSL.</li><li><strong>Certificates</strong>: Presenting certificates to a client and authentication of client certificates.</li><li><strong>Compression</strong>: Compression of responses.</li><li><strong>Caching</strong>: An application-layer load balancer may offer the ability to cache responses.</li><li><strong>Logging</strong>: Logging of request and response metadata can serve as an important audit trail or source for analytics data.</li><li><strong>Request tracing</strong>: Assigning each request a unique id for the purposes of logging, monitoring, and troubleshooting.</li><li><strong>Redirects</strong>: The ability to redirect an incoming request based on factors such as the requested path.</li><li><strong>Fixed response</strong>: Returning a static response for a request such as an error message.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="examples-1">Examples<a href="#examples-1" class="hash-link" aria-label="Examples的直接链接" title="Examples的直接链接">​</a></h3><p>Following are some of the load balancing solutions commonly used in the industry:</p><ul><li><a href="https://aws.amazon.com/elasticloadbalancing" target="_blank" rel="noopener noreferrer">Amazon Elastic Load Balancing</a></li><li><a href="https://azure.microsoft.com/en-in/services/load-balancer" target="_blank" rel="noopener noreferrer">Azure Load Balancing</a></li><li><a href="https://cloud.google.com/load-balancing" target="_blank" rel="noopener noreferrer">GCP Load Balancing</a></li><li><a href="https://www.digitalocean.com/products/load-balancer" target="_blank" rel="noopener noreferrer">DigitalOcean Load Balancer</a></li><li><a href="https://www.nginx.com" target="_blank" rel="noopener noreferrer">Nginx</a></li><li><a href="http://www.haproxy.org" target="_blank" rel="noopener noreferrer">HAProxy</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="clustering">Clustering<a href="#clustering" class="hash-link" aria-label="Clustering的直接链接" title="Clustering的直接链接">​</a></h2><p>At a high level, a computer cluster is a group of two or more computers, or nodes, that run in parallel to achieve a common goal. This allows workloads consisting of a high number of individual, parallelizable tasks to be distributed among the nodes in the cluster. As a result, these tasks can leverage the combined memory and processing power of each computer to increase overall performance.</p><p>To build a computer cluster, the individual nodes should be connected to a network to enable internode communication. The software can then be used to join the nodes together and form a cluster. It may have a shared storage device and/or local storage on each node.</p><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/clustering/cluster.png" alt="cluster" class="img_ev3q"></p><p>Typically, at least one node is designated as the leader node and acts as the entry point to the cluster. The leader node may be responsible for delegating incoming work to the other nodes and, if necessary, aggregating the results and returning a response to the user.</p><p>Ideally, a cluster functions as if it were a single system. A user accessing the cluster should not need to know whether the system is a cluster or an individual machine. Furthermore, a cluster should be designed to minimize latency and prevent bottlenecks in node-to-node communication.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="types-2">Types<a href="#types-2" class="hash-link" aria-label="Types的直接链接" title="Types的直接链接">​</a></h3><p>Computer clusters can generally be categorized into three types:</p><ul><li>Highly available or fail-over</li><li>Load balancing</li><li>High-performance computing</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="configurations">Configurations<a href="#configurations" class="hash-link" aria-label="Configurations的直接链接" title="Configurations的直接链接">​</a></h3><p>The two most commonly used high availability (HA) clustering configurations are active-active and active-passive.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="active-active">Active-Active<a href="#active-active" class="hash-link" aria-label="Active-Active的直接链接" title="Active-Active的直接链接">​</a></h4><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/clustering/active-active.png" alt="active-active" class="img_ev3q"></p><p>An active-active cluster is typically made up of at least two nodes, both actively running the same kind of service simultaneously. The main purpose of an active-active cluster is to achieve load balancing. A load balancer distributes workloads across all nodes to prevent any single node from getting overloaded. Because there are more nodes available to serve, there will also be an improvement in throughput and response times.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="active-passive">Active-Passive<a href="#active-passive" class="hash-link" aria-label="Active-Passive的直接链接" title="Active-Passive的直接链接">​</a></h4><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/clustering/active-passive.png" alt="active-passive" class="img_ev3q"></p><p>Like the active-active cluster configuration, an active-passive cluster also consists of at least two nodes. However, as the name <em>active-passive</em> implies, not all nodes are going to be active. For example, in the case of two nodes, if the first node is already active, then the second node must be passive or on standby.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="advantages-1">Advantages<a href="#advantages-1" class="hash-link" aria-label="Advantages的直接链接" title="Advantages的直接链接">​</a></h3><p>Four key advantages of cluster computing are as follows:</p><ul><li>High availability</li><li>Scalability</li><li>Performance</li><li>Cost-effective</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="load-balancing-vs-clustering">Load balancing vs Clustering<a href="#load-balancing-vs-clustering" class="hash-link" aria-label="Load balancing vs Clustering的直接链接" title="Load balancing vs Clustering的直接链接">​</a></h3><p>Load balancing shares some common traits with clustering, but they are different processes. Clustering provides redundancy and boosts capacity and availability. Servers in a cluster are aware of each other and work together toward a common purpose. But with load balancing, servers are not aware of each other. Instead, they react to the requests they receive from the load balancer.</p><p>We can employ load balancing in conjunction with clustering, but it also is applicable in cases involving independent servers that share a common purpose such as to run a website, business application, web service, or some other IT resource.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="challenges">Challenges<a href="#challenges" class="hash-link" aria-label="Challenges的直接链接" title="Challenges的直接链接">​</a></h3><p>The most obvious challenge clustering presents is the increased complexity of installation and maintenance. An operating system, the application, and its dependencies must each be installed and updated on every node.</p><p>This becomes even more complicated if the nodes in the cluster are not homogeneous. Resource utilization for each node must also be closely monitored, and logs should be aggregated to ensure that the software is behaving correctly.</p><p>Additionally, storage becomes more difficult to manage, a shared storage device must prevent nodes from overwriting one another and distributed data stores have to be kept in sync.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="examples-2">Examples<a href="#examples-2" class="hash-link" aria-label="Examples的直接链接" title="Examples的直接链接">​</a></h3><p>Clustering is commonly used in the industry, and often many technologies offer some sort of clustering mode. For example:</p><ul><li>Containers (e.g. <a href="https://kubernetes.io" target="_blank" rel="noopener noreferrer">Kubernetes</a>, <a href="https://aws.amazon.com/ecs" target="_blank" rel="noopener noreferrer">Amazon ECS</a>)</li><li>Databases (e.g. <a href="https://cassandra.apache.org/_/index.html" target="_blank" rel="noopener noreferrer">Cassandra</a>, <a href="https://www.mongodb.com" target="_blank" rel="noopener noreferrer">MongoDB</a>)</li><li>Cache (e.g. <a href="https://redis.io/docs/manual/scaling" target="_blank" rel="noopener noreferrer">Redis</a>)</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="caching">Caching<a href="#caching" class="hash-link" aria-label="Caching的直接链接" title="Caching的直接链接">​</a></h2><p><em>&quot;There are only two hard things in Computer Science: cache invalidation and naming things.&quot; - Phil Karlton</em></p><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/caching.png" alt="caching" class="img_ev3q"></p><p>A cache&#x27;s primary purpose is to increase data retrieval performance by reducing the need to access the underlying slower storage layer. Trading off capacity for speed, a cache typically stores a subset of data transiently, in contrast to databases whose data is usually complete and durable.</p><p>Caches take advantage of the locality of reference principle <em>&quot;recently requested data is likely to be requested again&quot;.</em></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="caching-and-memory">Caching and Memory<a href="#caching-and-memory" class="hash-link" aria-label="Caching and Memory的直接链接" title="Caching and Memory的直接链接">​</a></h3><p>Like a computer&#x27;s memory, a cache is a compact, fast-performing memory that stores data in a hierarchy of levels, starting at level one, and progressing from there sequentially. They are labeled as L1, L2, L3, and so on. A cache also gets written if requested, such as when there has been an update and new content needs to be saved to the cache, replacing the older content that was saved.</p><p>No matter whether the cache is read or written, it&#x27;s done one block at a time. Each block also has a tag that includes the location where the data was stored in the cache. When data is requested from the cache, a search occurs through the tags to find the specific content that&#x27;s needed in level one (L1) of the memory. If the correct data isn&#x27;t found, more searches are conducted in L2.</p><p>If the data isn&#x27;t found there, searches are continued in L3, then L4, and so on until it has been found, then, it&#x27;s read and loaded. If the data isn&#x27;t found in the cache at all, then it&#x27;s written into it for quick retrieval the next time.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cache-hit-and-cache-miss">Cache hit and Cache miss<a href="#cache-hit-and-cache-miss" class="hash-link" aria-label="Cache hit and Cache miss的直接链接" title="Cache hit and Cache miss的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="cache-hit">Cache hit<a href="#cache-hit" class="hash-link" aria-label="Cache hit的直接链接" title="Cache hit的直接链接">​</a></h4><p>A cache hit describes the situation where content is successfully served from the cache. The tags are searched in the memory rapidly, and when the data is found and read, it&#x27;s considered a cache hit.</p><p><strong>Cold, Warm, and Hot Caches</strong></p><p>A cache hit can also be described as cold, warm, or hot. In each of these, the speed at which the data is read is described.</p><p>A hot cache is an instance where data was read from the memory at the <em>fastest</em> possible rate. This happens when the data is retrieved from L1.</p><p>A cold cache is the <em>slowest</em> possible rate for data to be read, though, it&#x27;s still successful so it&#x27;s still considered a cache hit. The data is just found lower in the memory hierarchy such as in L3, or lower.</p><p>A warm cache is used to describe data that&#x27;s found in L2 or L3. It&#x27;s not as fast as a hot cache, but it&#x27;s still faster than a cold cache. Generally, calling a cache warm is used to express that it&#x27;s slower and closer to a cold cache than a hot one.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="cache-miss">Cache miss<a href="#cache-miss" class="hash-link" aria-label="Cache miss的直接链接" title="Cache miss的直接链接">​</a></h4><p>A cache miss refers to the instance when the memory is searched, and the data isn&#x27;t found. When this happens, the content is transferred and written into the cache.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cache-invalidation">Cache Invalidation<a href="#cache-invalidation" class="hash-link" aria-label="Cache Invalidation的直接链接" title="Cache Invalidation的直接链接">​</a></h3><p>Cache invalidation is a process where the computer system declares the cache entries as invalid and removes or replaces them. If the data is modified, it should be invalidated in the cache, if not, this can cause inconsistent application behavior. There are three kinds of caching systems:</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="write-through-cache">Write-through cache<a href="#write-through-cache" class="hash-link" aria-label="Write-through cache的直接链接" title="Write-through cache的直接链接">​</a></h4><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/write-through-cache.png" alt="write-through-cache" class="img_ev3q"></p><p>Data is written into the cache and the corresponding database simultaneously.</p><p><strong>Pro</strong>: Fast retrieval, complete data consistency between cache and storage.</p><p><strong>Con</strong>: Higher latency for write operations.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="write-around-cache">Write-around cache<a href="#write-around-cache" class="hash-link" aria-label="Write-around cache的直接链接" title="Write-around cache的直接链接">​</a></h4><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/write-around-cache.png" alt="write-around-cache" class="img_ev3q"></p><p>Where write directly goes to the database or permanent storage, bypassing the cache.</p><p><strong>Pro</strong>: This may reduce latency.</p><p><strong>Con</strong>: It increases cache misses because the cache system has to read the information from the database in case of a cache miss. As a result, this can lead to higher read latency in the case of applications that write and re-read the information quickly. Read happen from slower back-end storage and experiences higher latency.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="write-back-cache">Write-back cache<a href="#write-back-cache" class="hash-link" aria-label="Write-back cache的直接链接" title="Write-back cache的直接链接">​</a></h4><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/write-back-cache.png" alt="write-back-cache" class="img_ev3q"></p><p>Where the write is only done to the caching layer and the write is confirmed as soon as the write to the cache completes. The cache then asynchronously syncs this write to the database.</p><p><strong>Pro</strong>: This would lead to reduced latency and high throughput for write-intensive applications.</p><p><strong>Con</strong>: There is a risk of data loss in case the caching layer crashes. We can improve this by having more than one replica acknowledging the write in the cache.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="eviction-policies">Eviction policies<a href="#eviction-policies" class="hash-link" aria-label="Eviction policies的直接链接" title="Eviction policies的直接链接">​</a></h3><p>Following are some of the most common cache eviction policies:</p><ul><li><strong>First In First Out (FIFO)</strong>: The cache evicts the first block accessed first without any regard to how often or how many times it was accessed before.</li><li><strong>Last In First Out (LIFO)</strong>: The cache evicts the block accessed most recently first without any regard to how often or how many times it was accessed before.</li><li><strong>Least Recently Used (LRU)</strong>: Discards the least recently used items first.</li><li><strong>Most Recently Used (MRU)</strong>: Discards, in contrast to LRU, the most recently used items first.</li><li><strong>Least Frequently Used (LFU)</strong>: Counts how often an item is needed. Those that are used least often are discarded first.</li><li><strong>Random Replacement (RR)</strong>: Randomly selects a candidate item and discards it to make space when necessary.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="distributed-cache">Distributed Cache<a href="#distributed-cache" class="hash-link" aria-label="Distributed Cache的直接链接" title="Distributed Cache的直接链接">​</a></h3><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/distributed-cache.png" alt="distributed-cache" class="img_ev3q"></p><p>A distributed cache is a system that pools together the random-access memory (RAM) of multiple networked computers into a single in-memory data store used as a data cache to provide fast access to data. While most caches are traditionally in one physical server or hardware component, a distributed cache can grow beyond the memory limits of a single computer by linking together multiple computers.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="global-cache">Global Cache<a href="#global-cache" class="hash-link" aria-label="Global Cache的直接链接" title="Global Cache的直接链接">​</a></h3><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/caching/global-cache.png" alt="global-cache" class="img_ev3q"></p><p>As the name suggests, we will have a single shared cache that all the application nodes will use. When the requested data is not found in the global cache, it&#x27;s the responsibility of the cache to find out the missing piece of data from the underlying data store.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="use-cases">Use cases<a href="#use-cases" class="hash-link" aria-label="Use cases的直接链接" title="Use cases的直接链接">​</a></h3><p>Caching can have many real-world use cases such as:</p><ul><li>Database Caching</li><li>Content Delivery Network (CDN)</li><li>Domain Name System (DNS) Caching</li><li>API Caching</li></ul><p><strong>When not to use caching?</strong></p><p>Let&#x27;s also look at some scenarios where we should not use cache:</p><ul><li>Caching isn&#x27;t helpful when it takes just as long to access the cache as it does to access the primary data store.</li><li>Caching doesn&#x27;t work as well when requests have low repetition (higher randomness), because caching performance comes from repeated memory access patterns.</li><li>Caching isn&#x27;t helpful when the data changes frequently, as the cached version gets out of sync, and the primary data store must be accessed every time.</li></ul><p><em>It&#x27;s important to note that a cache should not be used as permanent data storage. They are almost always implemented in volatile memory because it is faster, and thus should be considered transient.</em></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="advantages-2">Advantages<a href="#advantages-2" class="hash-link" aria-label="Advantages的直接链接" title="Advantages的直接链接">​</a></h3><p>Below are some advantages of caching:</p><ul><li>Improves performance</li><li>Reduce latency</li><li>Reduce load on the database</li><li>Reduce network cost</li><li>Increase Read Throughput</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="examples-3">Examples<a href="#examples-3" class="hash-link" aria-label="Examples的直接链接" title="Examples的直接链接">​</a></h3><p>Here are some commonly used technologies for caching:</p><ul><li><a href="https://redis.io" target="_blank" rel="noopener noreferrer">Redis</a></li><li><a href="https://memcached.org" target="_blank" rel="noopener noreferrer">Memcached</a></li><li><a href="https://aws.amazon.com/elasticache" target="_blank" rel="noopener noreferrer">Amazon Elasticache</a></li><li><a href="https://aerospike.com" target="_blank" rel="noopener noreferrer">Aerospike</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="content-delivery-network-cdn">Content Delivery Network (CDN)<a href="#content-delivery-network-cdn" class="hash-link" aria-label="Content Delivery Network (CDN)的直接链接" title="Content Delivery Network (CDN)的直接链接">​</a></h2><p>A content delivery network (CDN) is a geographically distributed group of servers that work together to provide fast delivery of internet content. Generally, static files such as HTML/CSS/JS, photos, and videos are served from CDN.</p><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/content-delivery-network/cdn-map.png" alt="cdn-map" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="why-use-a-cdn">Why use a CDN?<a href="#why-use-a-cdn" class="hash-link" aria-label="Why use a CDN?的直接链接" title="Why use a CDN?的直接链接">​</a></h3><p>Content Delivery Network (CDN) increases content availability and redundancy while reducing bandwidth costs and improving security. Serving content from CDNs can significantly improve performance as users receive content from data centers close to them and our servers do not have to serve requests that the CDN fulfills.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="how-does-a-cdn-work">How does a CDN work?<a href="#how-does-a-cdn-work" class="hash-link" aria-label="How does a CDN work?的直接链接" title="How does a CDN work?的直接链接">​</a></h3><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/content-delivery-network/cdn.png" alt="cdn" class="img_ev3q"></p><p>In a CDN, the origin server contains the original versions of the content while the edge servers are numerous and distributed across various locations around the world.</p><p>To minimize the distance between the visitors and the website&#x27;s server, a CDN stores a cached version of its content in multiple geographical locations known as edge locations. Each edge location contains several caching servers responsible for content delivery to visitors within its proximity.</p><p>Once the static assets are cached on all the CDN servers for a particular location, all subsequent website visitor requests for static assets will be delivered from these edge servers instead of the origin, thus reducing the origin load and improving scalability.</p><p>For example, when someone in the UK requests our website which might be hosted in the USA, they will be served from the closest edge location such as the London edge location. This is much quicker than having the visitor make a complete request to the origin server which will increase the latency.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="types-3">Types<a href="#types-3" class="hash-link" aria-label="Types的直接链接" title="Types的直接链接">​</a></h3><p>CDNs are generally divided into two types:</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="push-cdns">Push CDNs<a href="#push-cdns" class="hash-link" aria-label="Push CDNs的直接链接" title="Push CDNs的直接链接">​</a></h4><p>Push CDNs receive new content whenever changes occur on the server. We take full responsibility for providing content, uploading directly to the CDN, and rewriting URLs to point to the CDN. We can configure when content expires and when it is updated. Content is uploaded only when it is new or changed, minimizing traffic, but maximizing storage.</p><p>Sites with a small amount of traffic or sites with content that isn&#x27;t often updated work well with push CDNs. Content is placed on the CDNs once, instead of being re-pulled at regular intervals.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="pull-cdns">Pull CDNs<a href="#pull-cdns" class="hash-link" aria-label="Pull CDNs的直接链接" title="Pull CDNs的直接链接">​</a></h4><p>In a Pull CDN situation, the cache is updated based on request. When the client sends a request that requires static assets to be fetched from the CDN if the CDN doesn&#x27;t have it, then it will fetch the newly updated assets from the origin server and populate its cache with this new asset, and then send this new cached asset to the user.</p><p>Contrary to the Push CDN, this requires less maintenance because cache updates on CDN nodes are performed based on requests from the client to the origin server. Sites with heavy traffic work well with pull CDNs, as traffic is spread out more evenly with only recently-requested content remaining on the CDN.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="disadvantages">Disadvantages<a href="#disadvantages" class="hash-link" aria-label="Disadvantages的直接链接" title="Disadvantages的直接链接">​</a></h3><p>As we all know good things come with extra costs, so let&#x27;s discuss some disadvantages of CDNs:</p><ul><li><strong>Extra charges</strong>: It can be expensive to use a CDN, especially for high-traffic services.</li><li><strong>Restrictions</strong>: Some organizations and countries have blocked the domains or IP addresses of popular CDNs.</li><li><strong>Location</strong>: If most of our audience is located in a country where the CDN has no servers, the data on our website may have to travel further than without using any CDN.</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="examples-4">Examples<a href="#examples-4" class="hash-link" aria-label="Examples的直接链接" title="Examples的直接链接">​</a></h3><p>Here are some widely used CDNs:</p><ul><li><a href="https://aws.amazon.com/cloudfront" target="_blank" rel="noopener noreferrer">Amazon CloudFront</a></li><li><a href="https://cloud.google.com/cdn" target="_blank" rel="noopener noreferrer">Google Cloud CDN</a></li><li><a href="https://www.cloudflare.com/cdn" target="_blank" rel="noopener noreferrer">Cloudflare CDN</a></li><li><a href="https://www.fastly.com/products/cdn" target="_blank" rel="noopener noreferrer">Fastly</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="proxy">Proxy<a href="#proxy" class="hash-link" aria-label="Proxy的直接链接" title="Proxy的直接链接">​</a></h2><p>A proxy server is an intermediary piece of hardware/software sitting between the client and the backend server. It receives requests from clients and relays them to the origin servers. Typically, proxies are used to filter requests, log requests, or sometimes transform requests (by adding/removing headers, encrypting/decrypting, or compression).</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="types-4">Types<a href="#types-4" class="hash-link" aria-label="Types的直接链接" title="Types的直接链接">​</a></h3><p>There are two types of proxies:</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="forward-proxy">Forward Proxy<a href="#forward-proxy" class="hash-link" aria-label="Forward Proxy的直接链接" title="Forward Proxy的直接链接">​</a></h4><p>A forward proxy, often called a proxy, proxy server, or web proxy is a server that sits in front of a group of client machines. When those computers make requests to sites and services on the internet, the proxy server intercepts those requests and then communicates with web servers on behalf of those clients, like a middleman.</p><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/proxy/forward-proxy.png" alt="forward-proxy" class="img_ev3q"></p><p><strong>Advantages</strong></p><p>Here are some advantages of a forward proxy:</p><ul><li>Block access to certain content</li><li>Allows access to <a href="https://en.wikipedia.org/wiki/Geo-blocking" target="_blank" rel="noopener noreferrer">geo-restricted</a> content</li><li>Provides anonymity</li><li>Avoid other browsing restrictions</li></ul><p>Although proxies provide the benefits of anonymity, they can still track our personal information. Setup and maintenance of a proxy server can be costly and requires configurations.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="reverse-proxy">Reverse Proxy<a href="#reverse-proxy" class="hash-link" aria-label="Reverse Proxy的直接链接" title="Reverse Proxy的直接链接">​</a></h4><p>A reverse proxy is a server that sits in front of one or more web servers, intercepting requests from clients. When clients send requests to the origin server of a website, those requests are intercepted by the reverse proxy server.</p><p>The difference between a forward and reverse proxy is subtle but important. A simplified way to sum it up would be to say that a forward proxy sits in front of a client and ensures that no origin server ever communicates directly with that specific client. On the other hand, a reverse proxy sits in front of an origin server and ensures that no client ever communicates directly with that origin server.</p><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/proxy/reverse-proxy.png" alt="reverse-proxy" class="img_ev3q"></p><p>Introducing reverse proxy results in increased complexity. A single reverse proxy is a single point of failure, configuring multiple reverse proxies (i.e. a failover) further increases complexity.</p><p><strong>Advantages</strong></p><p>Here are some advantages of using a reverse proxy:</p><ul><li>Improved security</li><li>Caching</li><li>SSL encryption</li><li>Load balancing</li><li>Scalability and flexibility</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="load-balancer-vs-reverse-proxy">Load balancer vs Reverse Proxy<a href="#load-balancer-vs-reverse-proxy" class="hash-link" aria-label="Load balancer vs Reverse Proxy的直接链接" title="Load balancer vs Reverse Proxy的直接链接">​</a></h3><p>Wait, isn&#x27;t reverse proxy similar to a load balancer? Well, no as a load balancer is useful when we have multiple servers. Often, load balancers route traffic to a set of servers serving the same function, while reverse proxies can be useful even with just one web server or application server. A reverse proxy can also act as a load balancer but not the other way around.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="examples-5">Examples<a href="#examples-5" class="hash-link" aria-label="Examples的直接链接" title="Examples的直接链接">​</a></h3><p>Below are some commonly used proxy technologies:</p><ul><li><a href="https://www.nginx.com" target="_blank" rel="noopener noreferrer">Nginx</a></li><li><a href="http://www.haproxy.org" target="_blank" rel="noopener noreferrer">HAProxy</a></li><li><a href="https://doc.traefik.io/traefik" target="_blank" rel="noopener noreferrer">Traefik</a></li><li><a href="https://www.envoyproxy.io" target="_blank" rel="noopener noreferrer">Envoy</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="availability">Availability<a href="#availability" class="hash-link" aria-label="Availability的直接链接" title="Availability的直接链接">​</a></h2><p>Availability is the time a system remains operational to perform its required function in a specific period. It is a simple measure of the percentage of time that a system, service, or machine remains operational under normal conditions.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-nines-of-availability">The Nine&#x27;s of availability<a href="#the-nines-of-availability" class="hash-link" aria-label="The Nine&#x27;s of availability的直接链接" title="The Nine&#x27;s of availability的直接链接">​</a></h3><p>Availability is often quantified by uptime (or downtime) as a percentage of time the service is available. It is generally measured in the number of 9s.</p><div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>U</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi></mrow><mrow><mo stretchy="false">(</mo><mi>U</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>+</mo><mi>D</mi><mi>o</mi><mi>w</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">Availability = \frac{Uptime}{(Uptime + Downtime)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord mathnormal">ai</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">abi</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:2.2963em;vertical-align:-0.936em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="mord mathnormal">pt</span><span class="mord mathnormal">im</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mord mathnormal">Do</span><span class="mord mathnormal" style="margin-right:0.02691em">w</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">im</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="mord mathnormal">pt</span><span class="mord mathnormal">im</span><span class="mord mathnormal">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></div><p>If availability is 99.00% available, it is said to have &quot;2 nines&quot; of availability, and if it is 99.9%, it is called &quot;3 nines&quot;, and so on.</p><table><thead><tr><th>Availability (Percent)</th><th>Downtime (Year)</th><th>Downtime (Month)</th><th>Downtime (Week)</th></tr></thead><tbody><tr><td>90% (one nine)</td><td>36.53 days</td><td>72 hours</td><td>16.8 hours</td></tr><tr><td>99% (two nines)</td><td>3.65 days</td><td>7.20 hours</td><td>1.68 hours</td></tr><tr><td>99.9% (three nines)</td><td>8.77 hours</td><td>43.8 minutes</td><td>10.1 minutes</td></tr><tr><td>99.99% (four nines)</td><td>52.6 minutes</td><td>4.32 minutes</td><td>1.01 minutes</td></tr><tr><td>99.999% (five nines)</td><td>5.25 minutes</td><td>25.9 seconds</td><td>6.05 seconds</td></tr><tr><td>99.9999% (six nines)</td><td>31.56 seconds</td><td>2.59 seconds</td><td>604.8 milliseconds</td></tr><tr><td>99.99999% (seven nines)</td><td>3.15 seconds</td><td>263 milliseconds</td><td>60.5 milliseconds</td></tr><tr><td>99.999999% (eight nines)</td><td>315.6 milliseconds</td><td>26.3 milliseconds</td><td>6 milliseconds</td></tr><tr><td>99.9999999% (nine nines)</td><td>31.6 milliseconds</td><td>2.6 milliseconds</td><td>0.6 milliseconds</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_LWe7" id="availability-in-sequence-vs-parallel">Availability in Sequence vs Parallel<a href="#availability-in-sequence-vs-parallel" class="hash-link" aria-label="Availability in Sequence vs Parallel的直接链接" title="Availability in Sequence vs Parallel的直接链接">​</a></h3><p>If a service consists of multiple components prone to failure, the service&#x27;s overall availability depends on whether the components are in sequence or in parallel.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="sequence">Sequence<a href="#sequence" class="hash-link" aria-label="Sequence的直接链接" title="Sequence的直接链接">​</a></h4><p>Overall availability decreases when two components are in sequence.</p><div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>T</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>F</mi><mi>o</mi><mi>o</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>B</mi><mi>a</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Availability \space (Total) = Availability \space (Foo) * Availability \space (Bar)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord mathnormal">ai</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">abi</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord mathnormal">ai</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">abi</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord mathnormal">oo</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord mathnormal">ai</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">abi</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mclose">)</span></span></span></span></span></div><p>For example, if both <code>Foo</code> and <code>Bar</code> each had 99.9% availability, their total availability in sequence would be 99.8%.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="parallel">Parallel<a href="#parallel" class="hash-link" aria-label="Parallel的直接链接" title="Parallel的直接链接">​</a></h4><p>Overall availability increases when two components are in parallel.</p><div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>T</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>F</mi><mi>o</mi><mi>o</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>y</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>B</mi><mi>a</mi><mi>r</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Availability \space (Total) = 1 - (1 - Availability \space (Foo)) * (1 - Availability \space (Bar))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord mathnormal">ai</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">abi</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord mathnormal">ai</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">abi</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em">F</span><span class="mord mathnormal">oo</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord mathnormal">ai</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">abi</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em">B</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mclose">))</span></span></span></span></span></div><p>For example, if both <code>Foo</code> and <code>Bar</code> each had 99.9% availability, their total availability in parallel would be 99.9999%.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="availability-vs-reliability">Availability vs Reliability<a href="#availability-vs-reliability" class="hash-link" aria-label="Availability vs Reliability的直接链接" title="Availability vs Reliability的直接链接">​</a></h3><p>If a system is reliable, it is available. However, if it is available, it is not necessarily reliable. In other words, high reliability contributes to high availability, but it is possible to achieve high availability even with an unreliable system.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="high-availability-vs-fault-tolerance">High availability vs Fault Tolerance<a href="#high-availability-vs-fault-tolerance" class="hash-link" aria-label="High availability vs Fault Tolerance的直接链接" title="High availability vs Fault Tolerance的直接链接">​</a></h3><p>Both high availability and fault tolerance apply to methods for providing high uptime levels. However, they accomplish the objective differently.</p><p>A fault-tolerant system has no service interruption but a significantly higher cost, while a highly available system has minimal service interruption. Fault-tolerance requires full hardware redundancy as if the main system fails, with no loss in uptime, another system should take over.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="scalability">Scalability<a href="#scalability" class="hash-link" aria-label="Scalability的直接链接" title="Scalability的直接链接">​</a></h2><p>Scalability is the measure of how well a system responds to changes by adding or removing resources to meet demands.</p><p><img loading="lazy" src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/scalability/scalability.png" alt="scalability" class="img_ev3q"></p><p>Let&#x27;s discuss different types of scaling:</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="vertical-scaling">Vertical scaling<a href="#vertical-scaling" class="hash-link" aria-label="Vertical scaling的直接链接" title="Vertical scaling的直接链接">​</a></h3><p>Vertical scaling (also known as scaling up) expands a system&#x27;s scalability by adding more power to an existing machine. In other words, vertical scaling refers to improving an application&#x27;s capability via increasing hardware capacity.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="advantages-3">Advantages<a href="#advantages-3" class="hash-link" aria-label="Advantages的直接链接" title="Advantages的直接链接">​</a></h4><ul><li>Simple to implement</li><li>Easier to manage</li><li>Data consistent</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="disadvantages-1">Disadvantages<a href="#disadvantages-1" class="hash-link" aria-label="Disadvantages的直接链接" title="Disadvantages的直接链接">​</a></h4><ul><li>Risk of high downtime</li><li>Harder to upgrade</li><li>Can be a single point of failure</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="horizontal-scaling">Horizontal scaling<a href="#horizontal-scaling" class="hash-link" aria-label="Horizontal scaling的直接链接" title="Horizontal scaling的直接链接">​</a></h3><p>Horizontal scaling (also known as scaling out) expands a system&#x27;s scale by adding more machines. It improves the performance of the server by adding more instances to the existing pool of servers, allowing the load to be distributed more evenly.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="advantages-4">Advantages<a href="#advantages-4" class="hash-link" aria-label="Advantages的直接链接" title="Advantages的直接链接">​</a></h4><ul><li>Increased redundancy</li><li>Better fault tolerance</li><li>Flexible and efficient</li><li>Easier to upgrade</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="disadvantages-2">Disadvantages<a href="#disadvantages-2" class="hash-link" aria-label="Disadvantages的直接链接" title="Disadvantages的直接链接">​</a></h4><ul><li>Increased complexity</li><li>Data inconsistency</li><li>Increased load on downstream services</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="storage">Storage<a href="#storage" class="hash-link" aria-label="Storage的直接链接" title="Storage的直接链接">​</a></h2><p>Storage is a mechanism that enables a system to retain data, either temporarily or permanently. This topic is mostly skipped over in the context of system design, however, it is important to have a basic understanding of some common types of storage techniques that can help us fine-tune our storage components. Let&#x27;s discuss some important storage concepts:</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="raid">RAID<a href="#raid" class="hash-link" aria-label="RAID的直接链接" title="RAID的直接链接">​</a></h3><p>RAID (Redundant Array of Independent Disks) is a way of storing the same data on multiple hard disks or solid-state drives (SSDs) to protect data in the case of a drive failure.</p><p>There are different RAID levels, however, and not all have the goal of providing redundancy. Let&#x27;s discuss some commonly used RAID levels:</p><ul><li><strong>RAID 0</strong>: Also known as striping, data is split evenly across all the drives in the array.</li><li><strong>RAID 1</strong>: Also known as mirroring, at least two drives contains the exact copy of a set of data. If a drive fails, others will still work.</li><li><strong>RAID 5</strong>: Striping with parity. Requires the use of at least 3 drives, striping the data across multiple drives like RAID 0, but also has a parity distributed across the drives.</li><li><strong>RAID 6</strong>: Striping with double parity. RAID 6 is like RAID 5, but the parity data are written to two drives.</li><li><strong>RAID 10</strong>: Combines striping plus mirroring from RAID 0 and RAID 1. It provides security by mirroring all data on secondary drives while using striping across each set of drives to speed up data transfers.</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="comparison">Comparison<a href="#comparison" class="hash-link" aria-label="Comparison的直接链接" title="Comparison的直接链接">​</a></h4><p>Let&#x27;s compare all the features of different RAID levels:</p><table><thead><tr><th>Features</th><th>RAID 0</th><th>RAID 1</th><th>RAID 5</th><th>RAID 6</th><th>RAID 10</th></tr></thead><tbody><tr><td>Description</td><td>Striping</td><td>Mirroring</td><td>Striping with Parity</td><td>Striping with double parity</td><td>Striping and Mirroring</td></tr><tr><td>Minimum Disks</td><td>2</td><td>2</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Read Performance</td><td>High</td><td>High</td><td>High</td><td>High</td><td>High</td></tr><tr><td>Write Performance</td><td>High</td><td>Medium</td><td>High</td><td>High</td><td>Medium</td></tr><tr><td>Cost</td><td>Low</td><td>High</td><td>Low</td><td>Low</td><td>High</td></tr><tr><td>Fault Tolerance</td><td>None</td><td>Single-drive failure</td><td>Single-drive failure</td><td>Two-drive failure</td><td>Up to one disk failure in each sub-array</td></tr><tr><td>Capacity Utilization</td><td>100%</td><td>50%</td><td>67%-94%</td><td>50%-80%</td><td>50%</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_LWe7" id="volumes">Volumes<a href="#volumes" class="hash-link" aria-label="Volumes的直接链接" title="Volumes的直接链接">​</a></h3><p>Volume is a fixed amount of storage on a disk or tape. The term volume is often used as a synonym for the storage itself, but it is possible for a single disk to contain more than one volume or a volume to span more than one disk.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="file-storage">File storage<a href="#file-storage" class="hash-link" aria-label="File storage的直接链接" title="File storage的直接链接">​</a></h3><p>File storage is a solution to store data as files and present it to its final users as a hierarchical directories structure. The main advantage is to provide a user-friendly solution to store and retrieve files. To locate a file in file storage, the complete path of the file is required. It is economical and easily structured and is usually found on hard drives, which means that they appear exactly the same for the user and on the hard drive.</p><p>Example: <a href="https://aws.amazon.com/efs" target="_blank" rel="noopener noreferrer">Amazon EFS</a>, <a href="https://azure.microsoft.com/en-in/services/storage/files" target="_blank" rel="noopener noreferrer">Azure files</a>, <a href="https://cloud.google.com/filestore" target="_blank" rel="noopener noreferrer">Google Cloud Filestore</a>, etc.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="block-storage">Block storage<a href="#block-storage" class="hash-link" aria-label="Block storage的直接链接" title="Block storage的直接链接">​</a></h3><p>Block storage divides data into blocks (chunks) and stores them as separate pieces. Each block of data is given a unique identifier, which allows a storage system to place the smaller pieces of data wherever it is most convenient.</p><p>Block storage also decouples data from user environments, allowing that data to be spread across multiple environments. This creates multiple paths to the data and allows the user to retrieve it quickly. When a user or application requests data from a block storage system, the underlying storage system reassembles the data blocks and presents the data to the user or application</p><p>Example: <a href="https://aws.amazon.com/ebs" target="_blank" rel="noopener noreferrer">Amazon EBS</a>.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="object-storage">Object Storage<a href="#object-storage" class="hash-link" aria-label="Object Storage的直接链接" title="Object Storage的直接链接">​</a></h3><p>Object storage, which is also known as object-based storage, breaks data files up into pieces called objects. It then stores those objects in a single repository, which can be spread out across multiple networked systems.</p><p>Example: <a href="https://aws.amazon.com/s3" target="_blank" rel="noopener noreferrer">Amazon S3</a>, <a href="https://azure.microsoft.com/en-in/services/storage/blobs" target="_blank" rel="noopener noreferrer">Azure Blob Storage</a>, <a href="https://cloud.google.com/storage" target="_blank" rel="noopener noreferrer">Google Cloud Storage</a>, etc.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nas">NAS<a href="#nas" class="hash-link" aria-label="NAS的直接链接" title="NAS的直接链接">​</a></h3><p>A NAS (Network Attached Storage) is a storage device connected to a network that allows storage and retrieval of data from a central location for authorized network users. NAS devices are flexible, meaning that as we need additional storage, we can add to what we have. It&#x27;s faster, less expensive, and provides all the benefits of a public cloud on-site, giving us complete control.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="hdfs">HDFS<a href="#hdfs" class="hash-link" aria-label="HDFS的直接链接" title="HDFS的直接链接">​</a></h3><p>The Hadoop Distributed File System (HDFS) is a distributed file system designed to run on commodity hardware. HDFS is highly fault-tolerant and is designed to be deployed on low-cost hardware. HDFS provides high throughput access to application data and is suitable for applications that have large data sets. It has many similarities with existing distributed file systems.</p><p>HDFS is designed to reliably store very large files across machines in a large cluster. It stores each file as a sequence of blocks, all blocks in a file except the last block are the same size. The blocks of a file are replicated for fault tolerance.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/imwito/imwito.github.io/tree/main/docs/system-design/chapter1.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/zh-Hans/docs/system-design/intro"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Intro</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/zh-Hans/docs/system-design/chapter2"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Chapter 2</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#ip" class="table-of-contents__link toc-highlight">IP</a><ul><li><a href="#versions" class="table-of-contents__link toc-highlight">Versions</a></li><li><a href="#types" class="table-of-contents__link toc-highlight">Types</a></li></ul></li><li><a href="#osi-model" class="table-of-contents__link toc-highlight">OSI Model</a><ul><li><a href="#why-does-the-osi-model-matter" class="table-of-contents__link toc-highlight">Why does the OSI model matter?</a></li><li><a href="#layers" class="table-of-contents__link toc-highlight">Layers</a></li></ul></li><li><a href="#tcp-and-udp" class="table-of-contents__link toc-highlight">TCP and UDP</a><ul><li><a href="#tcp" class="table-of-contents__link toc-highlight">TCP</a></li><li><a href="#udp" class="table-of-contents__link toc-highlight">UDP</a></li><li><a href="#tcp-vs-udp" class="table-of-contents__link toc-highlight">TCP vs UDP</a></li></ul></li><li><a href="#domain-name-system-dns" class="table-of-contents__link toc-highlight">Domain Name System (DNS)</a><ul><li><a href="#how-dns-works" class="table-of-contents__link toc-highlight">How DNS works</a></li><li><a href="#server-types" class="table-of-contents__link toc-highlight">Server types</a></li><li><a href="#query-types" class="table-of-contents__link toc-highlight">Query Types</a></li><li><a href="#record-types" class="table-of-contents__link toc-highlight">Record Types</a></li><li><a href="#subdomains" class="table-of-contents__link toc-highlight">Subdomains</a></li><li><a href="#dns-zones" class="table-of-contents__link toc-highlight">DNS Zones</a></li><li><a href="#dns-caching" class="table-of-contents__link toc-highlight">DNS Caching</a></li><li><a href="#reverse-dns" class="table-of-contents__link toc-highlight">Reverse DNS</a></li><li><a href="#examples" class="table-of-contents__link toc-highlight">Examples</a></li></ul></li><li><a href="#load-balancing" class="table-of-contents__link toc-highlight">Load Balancing</a><ul><li><a href="#but-why" class="table-of-contents__link toc-highlight">But why?</a></li><li><a href="#workload-distribution" class="table-of-contents__link toc-highlight">Workload distribution</a></li><li><a href="#layers-1" class="table-of-contents__link toc-highlight">Layers</a></li><li><a href="#types-1" class="table-of-contents__link toc-highlight">Types</a></li><li><a href="#routing-algorithms" class="table-of-contents__link toc-highlight">Routing Algorithms</a></li><li><a href="#advantages" class="table-of-contents__link toc-highlight">Advantages</a></li><li><a href="#redundant-load-balancers" class="table-of-contents__link toc-highlight">Redundant load balancers</a></li><li><a href="#features" class="table-of-contents__link toc-highlight">Features</a></li><li><a href="#examples-1" class="table-of-contents__link toc-highlight">Examples</a></li></ul></li><li><a href="#clustering" class="table-of-contents__link toc-highlight">Clustering</a><ul><li><a href="#types-2" class="table-of-contents__link toc-highlight">Types</a></li><li><a href="#configurations" class="table-of-contents__link toc-highlight">Configurations</a></li><li><a href="#advantages-1" class="table-of-contents__link toc-highlight">Advantages</a></li><li><a href="#load-balancing-vs-clustering" class="table-of-contents__link toc-highlight">Load balancing vs Clustering</a></li><li><a href="#challenges" class="table-of-contents__link toc-highlight">Challenges</a></li><li><a href="#examples-2" class="table-of-contents__link toc-highlight">Examples</a></li></ul></li><li><a href="#caching" class="table-of-contents__link toc-highlight">Caching</a><ul><li><a href="#caching-and-memory" class="table-of-contents__link toc-highlight">Caching and Memory</a></li><li><a href="#cache-hit-and-cache-miss" class="table-of-contents__link toc-highlight">Cache hit and Cache miss</a></li><li><a href="#cache-invalidation" class="table-of-contents__link toc-highlight">Cache Invalidation</a></li><li><a href="#eviction-policies" class="table-of-contents__link toc-highlight">Eviction policies</a></li><li><a href="#distributed-cache" class="table-of-contents__link toc-highlight">Distributed Cache</a></li><li><a href="#global-cache" class="table-of-contents__link toc-highlight">Global Cache</a></li><li><a href="#use-cases" class="table-of-contents__link toc-highlight">Use cases</a></li><li><a href="#advantages-2" class="table-of-contents__link toc-highlight">Advantages</a></li><li><a href="#examples-3" class="table-of-contents__link toc-highlight">Examples</a></li></ul></li><li><a href="#content-delivery-network-cdn" class="table-of-contents__link toc-highlight">Content Delivery Network (CDN)</a><ul><li><a href="#why-use-a-cdn" class="table-of-contents__link toc-highlight">Why use a CDN?</a></li><li><a href="#how-does-a-cdn-work" class="table-of-contents__link toc-highlight">How does a CDN work?</a></li><li><a href="#types-3" class="table-of-contents__link toc-highlight">Types</a></li><li><a href="#disadvantages" class="table-of-contents__link toc-highlight">Disadvantages</a></li><li><a href="#examples-4" class="table-of-contents__link toc-highlight">Examples</a></li></ul></li><li><a href="#proxy" class="table-of-contents__link toc-highlight">Proxy</a><ul><li><a href="#types-4" class="table-of-contents__link toc-highlight">Types</a></li><li><a href="#load-balancer-vs-reverse-proxy" class="table-of-contents__link toc-highlight">Load balancer vs Reverse Proxy</a></li><li><a href="#examples-5" class="table-of-contents__link toc-highlight">Examples</a></li></ul></li><li><a href="#availability" class="table-of-contents__link toc-highlight">Availability</a><ul><li><a href="#the-nines-of-availability" class="table-of-contents__link toc-highlight">The Nine&#39;s of availability</a></li><li><a href="#availability-in-sequence-vs-parallel" class="table-of-contents__link toc-highlight">Availability in Sequence vs Parallel</a></li><li><a href="#availability-vs-reliability" class="table-of-contents__link toc-highlight">Availability vs Reliability</a></li><li><a href="#high-availability-vs-fault-tolerance" class="table-of-contents__link toc-highlight">High availability vs Fault Tolerance</a></li></ul></li><li><a href="#scalability" class="table-of-contents__link toc-highlight">Scalability</a><ul><li><a href="#vertical-scaling" class="table-of-contents__link toc-highlight">Vertical scaling</a></li><li><a href="#horizontal-scaling" class="table-of-contents__link toc-highlight">Horizontal scaling</a></li></ul></li><li><a href="#storage" class="table-of-contents__link toc-highlight">Storage</a><ul><li><a href="#raid" class="table-of-contents__link toc-highlight">RAID</a></li><li><a href="#volumes" class="table-of-contents__link toc-highlight">Volumes</a></li><li><a href="#file-storage" class="table-of-contents__link toc-highlight">File storage</a></li><li><a href="#block-storage" class="table-of-contents__link toc-highlight">Block storage</a></li><li><a href="#object-storage" class="table-of-contents__link toc-highlight">Object Storage</a></li><li><a href="#nas" class="table-of-contents__link toc-highlight">NAS</a></li><li><a href="#hdfs" class="table-of-contents__link toc-highlight">HDFS</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 imwito, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/zh-Hans/assets/js/runtime~main.c214fdea.js"></script>
<script src="/zh-Hans/assets/js/main.c22237af.js"></script>
</body>
</html>