"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2014],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(7294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var o=n.createContext({}),u=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=u(e.components);return n.createElement(o.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(a),m=s,h=p["".concat(o,".").concat(m)]||p[m]||d[m]||i;return a?n.createElement(h,r(r({ref:t},c),{},{components:a})):n.createElement(h,r({ref:t},c))}));function h(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=a.length,r=new Array(i);r[0]=m;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[p]="string"==typeof e?e:s,r[1]=l;for(var u=2;u<i;u++)r[u]=a[u];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},8032:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var n=a(7462),s=(a(7294),a(3905));const i={sidebar_position:3},r="Chapter 3",l={unversionedId:"system-design/chapter3",id:"system-design/chapter3",title:"Chapter 3",description:"N-tier architecture",source:"@site/i18n/zh-Hans/docusaurus-plugin-content-docs/current/system-design/chapter3.md",sourceDirName:"system-design",slug:"/system-design/chapter3",permalink:"/zh-Hans/docs/system-design/chapter3",draft:!1,editUrl:"https://github.com/imwito/imwito.github.io/tree/main/docs/system-design/chapter3.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Chapter 2",permalink:"/zh-Hans/docs/system-design/chapter2"},next:{title:"Chapter 4",permalink:"/zh-Hans/docs/system-design/chapter4"}},o={},u=[{value:"N-tier architecture",id:"n-tier-architecture",level:2},{value:"Types of N-Tier architectures",id:"types-of-n-tier-architectures",level:3},{value:"3-Tier architecture",id:"3-tier-architecture",level:4},{value:"2-Tier architecture",id:"2-tier-architecture",level:4},{value:"Single Tier or 1-Tier architecture",id:"single-tier-or-1-tier-architecture",level:4},{value:"Advantages",id:"advantages",level:3},{value:"Disadvantages",id:"disadvantages",level:3},{value:"Message Brokers",id:"message-brokers",level:2},{value:"Models",id:"models",level:3},{value:"Message brokers vs Event streaming",id:"message-brokers-vs-event-streaming",level:3},{value:"Message brokers vs Enterprise Service Bus (ESB)",id:"message-brokers-vs-enterprise-service-bus-esb",level:3},{value:"Examples",id:"examples",level:3},{value:"Message Queues",id:"message-queues",level:2},{value:"Working",id:"working",level:3},{value:"Advantages",id:"advantages-1",level:3},{value:"Features",id:"features",level:3},{value:"Push or Pull Delivery",id:"push-or-pull-delivery",level:4},{value:"FIFO (First-In-First-Out) Queues",id:"fifo-first-in-first-out-queues",level:4},{value:"Schedule or Delay Delivery",id:"schedule-or-delay-delivery",level:4},{value:"At-Least-Once Delivery",id:"at-least-once-delivery",level:4},{value:"Exactly-Once Delivery",id:"exactly-once-delivery",level:4},{value:"Dead-letter Queues",id:"dead-letter-queues",level:4},{value:"Ordering",id:"ordering",level:4},{value:"Poison-pill Messages",id:"poison-pill-messages",level:4},{value:"Security",id:"security",level:4},{value:"Task Queues",id:"task-queues",level:4},{value:"Backpressure",id:"backpressure",level:3},{value:"Examples",id:"examples-1",level:3},{value:"Publish-Subscribe",id:"publish-subscribe",level:2},{value:"Working",id:"working-1",level:3},{value:"Advantages",id:"advantages-2",level:3},{value:"Features",id:"features-1",level:3},{value:"Push Delivery",id:"push-delivery",level:4},{value:"Multiple Delivery Protocols",id:"multiple-delivery-protocols",level:4},{value:"Fanout",id:"fanout",level:4},{value:"Filtering",id:"filtering",level:4},{value:"Durability",id:"durability",level:4},{value:"Security",id:"security-1",level:4},{value:"Examples",id:"examples-2",level:3},{value:"Enterprise Service Bus (ESB)",id:"enterprise-service-bus-esb",level:2},{value:"Advantages",id:"advantages-3",level:3},{value:"Disadvantages",id:"disadvantages-1",level:3},{value:"Examples",id:"examples-3",level:3},{value:"Monoliths and Microservices",id:"monoliths-and-microservices",level:2},{value:"Monoliths",id:"monoliths",level:3},{value:"Advantages",id:"advantages-4",level:4},{value:"Disadvantages",id:"disadvantages-2",level:4},{value:"Modular Monoliths",id:"modular-monoliths",level:3},{value:"Microservices",id:"microservices",level:3},{value:"Characteristics",id:"characteristics",level:4},{value:"Advantages",id:"advantages-5",level:4},{value:"Disadvantages",id:"disadvantages-3",level:4},{value:"Best practices",id:"best-practices",level:4},{value:"Pitfalls",id:"pitfalls",level:4},{value:"Beware of the distributed monolith",id:"beware-of-the-distributed-monolith",level:3},{value:"Microservices vs Service-oriented architecture (SOA)",id:"microservices-vs-service-oriented-architecture-soa",level:3},{value:"Why you don&#39;t need microservices",id:"why-you-dont-need-microservices",level:3},{value:"Event-Driven Architecture (EDA)",id:"event-driven-architecture-eda",level:2},{value:"What is an event?",id:"what-is-an-event",level:3},{value:"Components",id:"components",level:3},{value:"Patterns",id:"patterns",level:3},{value:"Advantages",id:"advantages-6",level:3},{value:"Challenges",id:"challenges",level:3},{value:"Use cases",id:"use-cases",level:3},{value:"Examples",id:"examples-4",level:3},{value:"Event Sourcing",id:"event-sourcing",level:2},{value:"Event sourcing vs Event-Driven Architecture (EDA)",id:"event-sourcing-vs-event-driven-architecture-eda",level:3},{value:"Advantages",id:"advantages-7",level:3},{value:"Disadvantages",id:"disadvantages-4",level:3},{value:"Command and Query Responsibility Segregation (CQRS)",id:"command-and-query-responsibility-segregation-cqrs",level:2},{value:"CQRS with Event Sourcing",id:"cqrs-with-event-sourcing",level:3},{value:"Advantages",id:"advantages-8",level:3},{value:"Disadvantages",id:"disadvantages-5",level:3},{value:"Use cases",id:"use-cases-1",level:3},{value:"API Gateway",id:"api-gateway",level:2},{value:"Why do we need an API Gateway?",id:"why-do-we-need-an-api-gateway",level:3},{value:"Features",id:"features-2",level:3},{value:"Advantages",id:"advantages-9",level:3},{value:"Disadvantages",id:"disadvantages-6",level:3},{value:"Backend For Frontend (BFF) pattern",id:"backend-for-frontend-bff-pattern",level:3},{value:"When to use this pattern?",id:"when-to-use-this-pattern",level:4},{value:"Examples",id:"examples-5",level:3},{value:"REST, GraphQL, gRPC",id:"rest-graphql-grpc",level:2},{value:"What&#39;s an API?",id:"whats-an-api",level:3},{value:"REST",id:"rest",level:3},{value:"Concepts",id:"concepts",level:4},{value:"Advantages",id:"advantages-10",level:4},{value:"Disadvantages",id:"disadvantages-7",level:4},{value:"Use cases",id:"use-cases-2",level:4},{value:"Example",id:"example",level:4},{value:"GraphQL",id:"graphql",level:3},{value:"Concepts",id:"concepts-1",level:4},{value:"Advantages",id:"advantages-11",level:4},{value:"Disadvantages",id:"disadvantages-8",level:4},{value:"Use cases",id:"use-cases-3",level:4},{value:"Example",id:"example-1",level:4},{value:"gRPC",id:"grpc",level:3},{value:"Concepts",id:"concepts-2",level:4},{value:"Advantages",id:"advantages-12",level:4},{value:"Disadvantages",id:"disadvantages-9",level:4},{value:"Use cases",id:"use-cases-4",level:4},{value:"Example",id:"example-2",level:4},{value:"REST vs GraphQL vs gRPC",id:"rest-vs-graphql-vs-grpc",level:3},{value:"Which API technology is better?",id:"which-api-technology-is-better",level:4},{value:"Long polling, WebSockets, Server-Sent Events (SSE)",id:"long-polling-websockets-server-sent-events-sse",level:2},{value:"Long polling",id:"long-polling",level:3},{value:"Working",id:"working-2",level:4},{value:"Advantages",id:"advantages-13",level:4},{value:"Disadvantages",id:"disadvantages-10",level:4},{value:"WebSockets",id:"websockets",level:3},{value:"Working",id:"working-3",level:4},{value:"Advantages",id:"advantages-14",level:4},{value:"Disadvantages",id:"disadvantages-11",level:4},{value:"Server-Sent Events (SSE)",id:"server-sent-events-sse",level:3},{value:"Working",id:"working-4",level:4},{value:"Advantages",id:"advantages-15",level:4},{value:"Disadvantages",id:"disadvantages-12",level:4}],c={toc:u},p="wrapper";function d(e){let{components:t,...a}=e;return(0,s.kt)(p,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"chapter-3"},"Chapter 3"),(0,s.kt)("h2",{id:"n-tier-architecture"},"N-tier architecture"),(0,s.kt)("p",null,"N-tier architecture divides an application into logical layers and physical tiers. Layers are a way to separate responsibilities and manage dependencies. Each layer has a specific responsibility. A higher layer can use services in a lower layer, but not the other way around."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/n-tier-architecture/n-tier-architecture.png",alt:"n-tier-architecture"})),(0,s.kt)("p",null,"Tiers are physically separated, running on separate machines. A tier can call to another tier directly, or use asynchronous messaging. Although each layer might be hosted in its own tier, that's not required. Several layers might be hosted on the same tier. Physically separating the tiers improves scalability and resiliency and adds latency from the additional network communication."),(0,s.kt)("p",null,"An N-tier architecture can be of two types:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"In a closed layer architecture, a layer can only call the next layer immediately down."),(0,s.kt)("li",{parentName:"ul"},"In an open layer architecture, a layer can call any of the layers below it.")),(0,s.kt)("p",null,"A closed-layer architecture limits the dependencies between layers. However, it might create unnecessary network traffic, if one layer simply passes requests along to the next layer."),(0,s.kt)("h3",{id:"types-of-n-tier-architectures"},"Types of N-Tier architectures"),(0,s.kt)("p",null,"Let's look at some examples of N-Tier architecture:"),(0,s.kt)("h4",{id:"3-tier-architecture"},"3-Tier architecture"),(0,s.kt)("p",null,"3-Tier is widely used and consists of the following different layers:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Presentation layer"),": Handles user interactions with the application."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Business Logic layer"),": Accepts the data from the application layer, validates it as per business logic and passes it to the data layer."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Data Access layer"),": Receives the data from the business layer and performs the necessary operation on the database.")),(0,s.kt)("h4",{id:"2-tier-architecture"},"2-Tier architecture"),(0,s.kt)("p",null,"In this architecture, the presentation layer runs on the client and communicates with a data store. There is no business logic layer or immediate layer between client and server."),(0,s.kt)("h4",{id:"single-tier-or-1-tier-architecture"},"Single Tier or 1-Tier architecture"),(0,s.kt)("p",null,"It is the simplest one as it is equivalent to running the application on a personal computer. All of the required components for an application to run are on a single application or server."),(0,s.kt)("h3",{id:"advantages"},"Advantages"),(0,s.kt)("p",null,"Here are some advantages of using N-tier architecture:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Can improve availability."),(0,s.kt)("li",{parentName:"ul"},"Better security as layers can behave like a firewall."),(0,s.kt)("li",{parentName:"ul"},"Separate tiers allow us to scale them as needed."),(0,s.kt)("li",{parentName:"ul"},"Improve maintenance as different people can manage different tiers.")),(0,s.kt)("h3",{id:"disadvantages"},"Disadvantages"),(0,s.kt)("p",null,"Below are some disadvantages of N-tier architecture:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Increased complexity of the system as a whole."),(0,s.kt)("li",{parentName:"ul"},"Increased network latency as the number of tiers increases."),(0,s.kt)("li",{parentName:"ul"},"Expensive as every tier will have its own hardware cost."),(0,s.kt)("li",{parentName:"ul"},"Difficult to manage network security.")),(0,s.kt)("h2",{id:"message-brokers"},"Message Brokers"),(0,s.kt)("p",null,"A message broker is a software that enables applications, systems, and services to communicate with each other and exchange information. The message broker does this by translating messages between formal messaging protocols. This allows interdependent services to ",(0,s.kt)("em",{parentName:"p"},'"talk"')," with one another directly, even if they were written in different languages or implemented on different platforms."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/message-brokers/message-broker.png",alt:"message-broker"})),(0,s.kt)("p",null,"Message brokers can validate, store, route, and deliver messages to the appropriate destinations. They serve as intermediaries between other applications, allowing senders to issue messages without knowing where the receivers are, whether or not they are active, or how many of them there are. This facilitates the decoupling of processes and services within systems."),(0,s.kt)("h3",{id:"models"},"Models"),(0,s.kt)("p",null,"Message brokers offer two basic message distribution patterns or messaging styles:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://karanpratapsingh.com/courses/system-design/message-queues"},"Point-to-Point messaging")),": This is the distribution pattern utilized in message queues with a one-to-one relationship between the message's sender and receiver."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://karanpratapsingh.com/courses/system-design/publish-subscribe"},"Publish-subscribe messaging")),": In this message distribution pattern, often referred to as ",(0,s.kt)("em",{parentName:"li"},'"pub/sub"'),", the producer of each message publishes it to a topic, and multiple message consumers subscribe to topics from which they want to receive messages.")),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"We will discuss these messaging patterns in detail in the later tutorials.")),(0,s.kt)("h3",{id:"message-brokers-vs-event-streaming"},"Message brokers vs Event streaming"),(0,s.kt)("p",null,"Message brokers can support two or more messaging patterns, including message queues and pub/sub, while event streaming platforms only offer pub/sub-style distribution patterns. Designed for use with high volumes of messages, event streaming platforms are readily scalable. They're capable of ordering streams of records into categories called ",(0,s.kt)("em",{parentName:"p"},"topics")," and storing them for a predetermined amount of time. Unlike message brokers, however, event streaming platforms cannot guarantee message delivery or track which consumers have received the messages."),(0,s.kt)("p",null,"Event streaming platforms offer more scalability than message brokers but fewer features that ensure fault tolerance like message resending, as well as more limited message routing and queueing capabilities."),(0,s.kt)("h3",{id:"message-brokers-vs-enterprise-service-bus-esb"},"Message brokers vs Enterprise Service Bus (ESB)"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://karanpratapsingh.com/courses/system-design/enterprise-service-bus"},"Enterprise Service Bus (ESB)")," infrastructure is complex and can be challenging to integrate and expensive to maintain. It's difficult to troubleshoot them when problems occur in production environments, they're not easy to scale, and updating is tedious."),(0,s.kt)("p",null,"Whereas message brokers are a ",(0,s.kt)("em",{parentName:"p"},'"lightweight"')," alternative to ESBs that provide similar functionality, a mechanism for inter-service communication, at a lower cost. They're well-suited for use in the ",(0,s.kt)("a",{parentName:"p",href:"https://karanpratapsingh.com/courses/system-design/monoliths-microservices#microservices"},"microservices architectures")," that have become more prevalent as ESBs have fallen out of favor."),(0,s.kt)("h3",{id:"examples"},"Examples"),(0,s.kt)("p",null,"Here are some commonly used message brokers:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://nats.io"},"NATS")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://kafka.apache.org"},"Apache Kafka")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://www.rabbitmq.com"},"RabbitMQ")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://activemq.apache.org"},"ActiveMQ"))),(0,s.kt)("h2",{id:"message-queues"},"Message Queues"),(0,s.kt)("p",null,"A message queue is a form of service-to-service communication that facilitates asynchronous communication. It asynchronously receives messages from producers and sends them to consumers."),(0,s.kt)("p",null,"Queues are used to effectively manage requests in large-scale distributed systems. In small systems with minimal processing loads and small databases, writes can be predictably fast. However, in more complex and large systems writes can take an almost non-deterministic amount of time."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/message-queues/message-queue.png",alt:"message-queue"})),(0,s.kt)("h3",{id:"working"},"Working"),(0,s.kt)("p",null,"Messages are stored in the queue until they are processed and deleted. Each message is processed only once by a single consumer. Here's how it works:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A producer publishes a job to the queue, then notifies the user of the job status."),(0,s.kt)("li",{parentName:"ul"},"A consumer picks up the job from the queue, processes it, then signals that the job is complete.")),(0,s.kt)("h3",{id:"advantages-1"},"Advantages"),(0,s.kt)("p",null,"Let's discuss some advantages of using a message queue:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Scalability"),": Message queues make it possible to scale precisely where we need to. When workloads peak, multiple instances of our application can add all requests to the queue without the risk of collision."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Decoupling"),": Message queues remove dependencies between components and significantly simplify the implementation of decoupled applications."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Performance"),": Message queues enable asynchronous communication, which means that the endpoints that are producing and consuming messages interact with the queue, not each other. Producers can add requests to the queue without waiting for them to be processed."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Reliability"),": Queues make our data persistent, and reduce the errors that happen when different parts of our system go offline.")),(0,s.kt)("h3",{id:"features"},"Features"),(0,s.kt)("p",null,"Now, let's discuss some desired features of message queues:"),(0,s.kt)("h4",{id:"push-or-pull-delivery"},"Push or Pull Delivery"),(0,s.kt)("p",null,"Most message queues provide both push and pull options for retrieving messages. Pull means continuously querying the queue for new messages. Push means that a consumer is notified when a message is available. We can also use long-polling to allow pulls to wait a specified amount of time for new messages to arrive."),(0,s.kt)("h4",{id:"fifo-first-in-first-out-queues"},"FIFO (First-In-First-Out) Queues"),(0,s.kt)("p",null,"In these queues, the oldest (or first) entry, sometimes called the ",(0,s.kt)("em",{parentName:"p"},'"head"')," of the queue, is processed first."),(0,s.kt)("h4",{id:"schedule-or-delay-delivery"},"Schedule or Delay Delivery"),(0,s.kt)("p",null,"Many message queues support setting a specific delivery time for a message. If we need to have a common delay for all messages, we can set up a delay queue."),(0,s.kt)("h4",{id:"at-least-once-delivery"},"At-Least-Once Delivery"),(0,s.kt)("p",null,"Message queues may store multiple copies of messages for redundancy and high availability, and resend messages in the event of communication failures or errors to ensure they are delivered at least once."),(0,s.kt)("h4",{id:"exactly-once-delivery"},"Exactly-Once Delivery"),(0,s.kt)("p",null,"When duplicates can't be tolerated, FIFO (first-in-first-out) message queues will make sure that each message is delivered exactly once (and only once) by filtering out duplicates automatically."),(0,s.kt)("h4",{id:"dead-letter-queues"},"Dead-letter Queues"),(0,s.kt)("p",null,"A dead-letter queue is a queue to which other queues can send messages that can't be processed successfully. This makes it easy to set them aside for further inspection without blocking the queue processing or spending CPU cycles on a message that might never be consumed successfully."),(0,s.kt)("h4",{id:"ordering"},"Ordering"),(0,s.kt)("p",null,"Most message queues provide best-effort ordering which ensures that messages are generally delivered in the same order as they're sent and that a message is delivered at least once."),(0,s.kt)("h4",{id:"poison-pill-messages"},"Poison-pill Messages"),(0,s.kt)("p",null,"Poison pills are special messages that can be received, but not processed. They are a mechanism used in order to signal a consumer to end its work so it is no longer waiting for new inputs, and are similar to closing a socket in a client/server model."),(0,s.kt)("h4",{id:"security"},"Security"),(0,s.kt)("p",null,"Message queues will authenticate applications that try to access the queue, this allows us to encrypt messages over the network as well as in the queue itself."),(0,s.kt)("h4",{id:"task-queues"},"Task Queues"),(0,s.kt)("p",null,"Tasks queues receive tasks and their related data, run them, then deliver their results. They can support scheduling and can be used to run computationally-intensive jobs in the background."),(0,s.kt)("h3",{id:"backpressure"},"Backpressure"),(0,s.kt)("p",null,"If queues start to grow significantly, the queue size can become larger than memory, resulting in cache misses, disk reads, and even slower performance. Backpressure can help by limiting the queue size, thereby maintaining a high throughput rate and good response times for jobs already in the queue. Once the queue fills up, clients get a server busy or HTTP 503 status code to try again later. Clients can retry the request at a later time, perhaps with ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Exponential_backoff"},"exponential backoff")," strategy."),(0,s.kt)("h3",{id:"examples-1"},"Examples"),(0,s.kt)("p",null,"Following are some widely used message queues:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://aws.amazon.com/sqs"},"Amazon SQS")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://www.rabbitmq.com"},"RabbitMQ")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://activemq.apache.org"},"ActiveMQ")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://zeromq.org"},"ZeroMQ"))),(0,s.kt)("h2",{id:"publish-subscribe"},"Publish-Subscribe"),(0,s.kt)("p",null,"Similar to a message queue, publish-subscribe is also a form of service-to-service communication that facilitates asynchronous communication. In a pub/sub model, any message published to a topic is pushed immediately to all the subscribers of the topic."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/publish-subscribe/publish-subscribe.png",alt:"publish-subscribe"})),(0,s.kt)("p",null,"The subscribers to the message topic often perform different functions, and can each do something different with the message in parallel. The publisher doesn't need to know who is using the information that it is broadcasting, and the subscribers don't need to know where the message comes from. This style of messaging is a bit different than message queues, where the component that sends the message often knows the destination it is sending to."),(0,s.kt)("h3",{id:"working-1"},"Working"),(0,s.kt)("p",null,"Unlike message queues, which batch messages until they are retrieved, message topics transfer messages with little or no queuing and push them out immediately to all subscribers. Here's how it works:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A message topic provides a lightweight mechanism to broadcast asynchronous event notifications and endpoints that allow software components to connect to the topic in order to send and receive those messages."),(0,s.kt)("li",{parentName:"ul"},"To broadcast a message, a component called a ",(0,s.kt)("em",{parentName:"li"},"publisher")," simply pushes a message to the topic."),(0,s.kt)("li",{parentName:"ul"},"All components that subscribe to the topic (known as ",(0,s.kt)("em",{parentName:"li"},"subscribers"),") will receive every message that was broadcasted.")),(0,s.kt)("h3",{id:"advantages-2"},"Advantages"),(0,s.kt)("p",null,"Let's discuss some advantages of using publish-subscribe:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Eliminate Polling"),": Message topics allow instantaneous, push-based delivery, eliminating the need for message consumers to periodically check or ",(0,s.kt)("em",{parentName:"li"},'"poll"')," for new information and updates. This promotes faster response time and reduces the delivery latency which can be particularly problematic in systems where delays cannot be tolerated."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Dynamic Targeting"),": Pub/Sub makes the discovery of services easier, more natural, and less error-prone. Instead of maintaining a roster of peers where an application can send messages, a publisher will simply post messages to a topic. Then, any interested party will subscribe its endpoint to the topic, and start receiving these messages. Subscribers can change, upgrade, multiply or disappear and the system dynamically adjusts."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Decoupled and Independent Scaling"),": Publishers and subscribers are decoupled and work independently from each other, which allows us to develop and scale them independently."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Simplify Communication"),": The Publish-Subscribe model reduces complexity by removing all the point-to-point connections with a single connection to a message topic, which will manage subscriptions and decide what messages should be delivered to which endpoints.")),(0,s.kt)("h3",{id:"features-1"},"Features"),(0,s.kt)("p",null,"Now, let's discuss some desired features of publish-subscribe:"),(0,s.kt)("h4",{id:"push-delivery"},"Push Delivery"),(0,s.kt)("p",null,"Pub/Sub messaging instantly pushes asynchronous event notifications when messages are published to the message topic. Subscribers are notified when a message is available."),(0,s.kt)("h4",{id:"multiple-delivery-protocols"},"Multiple Delivery Protocols"),(0,s.kt)("p",null,"In the Publish-Subscribe model, topics can typically connect to multiple types of endpoints, such as message queues, serverless functions, HTTP servers, etc."),(0,s.kt)("h4",{id:"fanout"},"Fanout"),(0,s.kt)("p",null,"This scenario happens when a message is sent to a topic and then replicated and pushed to multiple endpoints. Fanout provides asynchronous event notifications which in turn allows for parallel processing."),(0,s.kt)("h4",{id:"filtering"},"Filtering"),(0,s.kt)("p",null,"This feature empowers the subscriber to create a message filtering policy so that it will only get the notifications it is interested in, as opposed to receiving every single message posted to the topic."),(0,s.kt)("h4",{id:"durability"},"Durability"),(0,s.kt)("p",null,"Pub/Sub messaging services often provide very high durability, and at least once delivery, by storing copies of the same message on multiple servers."),(0,s.kt)("h4",{id:"security-1"},"Security"),(0,s.kt)("p",null,"Message topics authenticate applications that try to publish content, this allows us to use encrypted endpoints and encrypt messages in transit over the network."),(0,s.kt)("h3",{id:"examples-2"},"Examples"),(0,s.kt)("p",null,"Here are some commonly used publish-subscribe technologies:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://aws.amazon.com/sns"},"Amazon SNS")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://cloud.google.com/pubsub"},"Google Pub/Sub"))),(0,s.kt)("h2",{id:"enterprise-service-bus-esb"},"Enterprise Service Bus (ESB)"),(0,s.kt)("p",null,"An Enterprise Service Bus (ESB) is an architectural pattern whereby a centralized software component performs integrations between applications. It performs transformations of data models, handles connectivity, performs message routing, converts communication protocols, and potentially manages the composition of multiple requests. The ESB can make these integrations and transformations available as a service interface for reuse by new applications."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/enterprise-service-bus/enterprise-service-bus.png",alt:"enterprise-service-bus"})),(0,s.kt)("h3",{id:"advantages-3"},"Advantages"),(0,s.kt)("p",null,"In theory, a centralized ESB offers the potential to standardize and dramatically simplify communication, messaging, and integration between services across the enterprise. Here are some advantages of using an ESB:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Improved developer productivity"),": Enables developers to incorporate new technologies into one part of an application without touching the rest of the application."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Simpler, more cost-effective scalability"),": Components can be scaled independently of others."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Greater resilience"),": Failure of one component does not impact the others, and each microservice can adhere to its own availability requirements without risking the availability of other components in the system.")),(0,s.kt)("h3",{id:"disadvantages-1"},"Disadvantages"),(0,s.kt)("p",null,"While ESBs were deployed successfully in many organizations, in many other organizations the ESB came to be seen as a bottleneck. Here are some disadvantages of using an ESB:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Making changes or enhancements to one integration could destabilize others who use that same integration."),(0,s.kt)("li",{parentName:"ul"},"A single point of failure can bring down all communications."),(0,s.kt)("li",{parentName:"ul"},"Updates to the ESB often impact existing integrations, so there is significant testing required to perform any update."),(0,s.kt)("li",{parentName:"ul"},"ESB is centrally managed which makes cross-team collaboration challenging."),(0,s.kt)("li",{parentName:"ul"},"High configuration and maintenance complexity.")),(0,s.kt)("h3",{id:"examples-3"},"Examples"),(0,s.kt)("p",null,"Below are some widely used Enterprise Service Bus (ESB) technologies:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://azure.microsoft.com/en-in/services/service-bus"},"Azure Service Bus")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://www.ibm.com/in-en/cloud/app-connect"},"IBM App Connect")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://camel.apache.org"},"Apache Camel")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://www.redhat.com/en/technologies/jboss-middleware/fuse"},"Fuse ESB"))),(0,s.kt)("h2",{id:"monoliths-and-microservices"},"Monoliths and Microservices"),(0,s.kt)("h3",{id:"monoliths"},"Monoliths"),(0,s.kt)("p",null,"A monolith is a self-contained and independent application. It is built as a single unit and is responsible for not just a particular task, but can perform every step needed to satisfy a business need."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/monoliths-microservices/monolith.png",alt:"monolith"})),(0,s.kt)("h4",{id:"advantages-4"},"Advantages"),(0,s.kt)("p",null,"Following are some advantages of monoliths:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Simple to develop or debug."),(0,s.kt)("li",{parentName:"ul"},"Fast and reliable communication."),(0,s.kt)("li",{parentName:"ul"},"Easy monitoring and testing."),(0,s.kt)("li",{parentName:"ul"},"Supports ACID transactions.")),(0,s.kt)("h4",{id:"disadvantages-2"},"Disadvantages"),(0,s.kt)("p",null,"Some common disadvantages of monoliths are:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Maintenance becomes hard as the codebase grows."),(0,s.kt)("li",{parentName:"ul"},"Tightly coupled application, hard to extend."),(0,s.kt)("li",{parentName:"ul"},"Requires commitment to a particular technology stack."),(0,s.kt)("li",{parentName:"ul"},"On each update, the entire application is redeployed."),(0,s.kt)("li",{parentName:"ul"},"Reduced reliability as a single bug can bring down the entire system."),(0,s.kt)("li",{parentName:"ul"},"Difficult to scale or adopt new technologies.")),(0,s.kt)("h3",{id:"modular-monoliths"},"Modular Monoliths"),(0,s.kt)("p",null,"A Modular Monolith is an approach where we build and deploy a single application (that's the ",(0,s.kt)("em",{parentName:"p"},"Monolith")," part), but we build it in a way that breaks up the code into independent modules for each of the features needed in our application."),(0,s.kt)("p",null,"This approach reduces the dependencies of a module in such as way that we can enhance or change a module without affecting other modules. When done right, this can be really beneficial in the long term as it reduces the complexity that comes with maintaining a monolith as the system grows."),(0,s.kt)("h3",{id:"microservices"},"Microservices"),(0,s.kt)("p",null,"A microservices architecture consists of a collection of small, autonomous services where each service is self-contained and should implement a single business capability within a bounded context. A bounded context is a natural division of business logic that provides an explicit boundary within which a domain model exists."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/monoliths-microservices/microservices.png",alt:"microservices"})),(0,s.kt)("p",null,"Each service has a separate codebase, which can be managed by a small development team. Services can be deployed independently and a team can update an existing service without rebuilding and redeploying the entire application."),(0,s.kt)("p",null,"Services are responsible for persisting their own data or external state (database per service). This differs from the traditional model, where a separate data layer handles data persistence."),(0,s.kt)("h4",{id:"characteristics"},"Characteristics"),(0,s.kt)("p",null,"The microservices architecture style has the following characteristics:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Loosely coupled"),": Services should be loosely coupled so that they can be independently deployed and scaled. This will lead to the decentralization of development teams and thus, enabling them to develop and deploy faster with minimal constraints and operational dependencies."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Small but focused"),": It's about scope and responsibilities and not size, a service should be focused on a specific problem. Basically, ",(0,s.kt)("em",{parentName:"li"},'"It does one thing and does it well"'),". Ideally, they can be independent of the underlying architecture."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Built for businesses"),": The microservices architecture is usually organized around business capabilities and priorities."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Resilience & Fault tolerance"),": Services should be designed in such a way that they still function in case of failure or errors. In environments with independently deployable services, failure tolerance is of the highest importance."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Highly maintainable"),": Service should be easy to maintain and test because services that cannot be maintained will be rewritten.")),(0,s.kt)("h4",{id:"advantages-5"},"Advantages"),(0,s.kt)("p",null,"Here are some advantages of microservices architecture:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Loosely coupled services."),(0,s.kt)("li",{parentName:"ul"},"Services can be deployed independently."),(0,s.kt)("li",{parentName:"ul"},"Highly agile for multiple development teams."),(0,s.kt)("li",{parentName:"ul"},"Improves fault tolerance and data isolation."),(0,s.kt)("li",{parentName:"ul"},"Better scalability as each service can be scaled independently."),(0,s.kt)("li",{parentName:"ul"},"Eliminates any long-term commitment to a particular technology stack.")),(0,s.kt)("h4",{id:"disadvantages-3"},"Disadvantages"),(0,s.kt)("p",null,"Microservices architecture brings its own set of challenges:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Complexity of a distributed system."),(0,s.kt)("li",{parentName:"ul"},"Testing is more difficult."),(0,s.kt)("li",{parentName:"ul"},"Expensive to maintain (individual servers, databases, etc.)."),(0,s.kt)("li",{parentName:"ul"},"Inter-service communication has its own challenges."),(0,s.kt)("li",{parentName:"ul"},"Data integrity and consistency."),(0,s.kt)("li",{parentName:"ul"},"Network congestion and latency.")),(0,s.kt)("h4",{id:"best-practices"},"Best practices"),(0,s.kt)("p",null,"Let's discuss some microservices best practices:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Model services around the business domain."),(0,s.kt)("li",{parentName:"ul"},"Services should have loose coupling and high functional cohesion."),(0,s.kt)("li",{parentName:"ul"},"Isolate failures and use resiliency strategies to prevent failures within a service from cascading."),(0,s.kt)("li",{parentName:"ul"},"Services should only communicate through well-designed APIs. Avoid leaking implementation details."),(0,s.kt)("li",{parentName:"ul"},"Data storage should be private to the service that owns the data"),(0,s.kt)("li",{parentName:"ul"},"Avoid coupling between services. Causes of coupling include shared database schemas and rigid communication protocols."),(0,s.kt)("li",{parentName:"ul"},"Decentralize everything. Individual teams are responsible for designing and building services. Avoid sharing code or data schemas."),(0,s.kt)("li",{parentName:"ul"},"Fail fast by using a ",(0,s.kt)("a",{parentName:"li",href:"https://karanpratapsingh.com/courses/system-design/circuit-breaker"},"circuit breaker")," to achieve fault tolerance."),(0,s.kt)("li",{parentName:"ul"},"Ensure that the API changes are backward compatible.")),(0,s.kt)("h4",{id:"pitfalls"},"Pitfalls"),(0,s.kt)("p",null,"Below are some common pitfalls of microservices architecture:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Service boundaries are not based on the business domain."),(0,s.kt)("li",{parentName:"ul"},"Underestimating how hard is to build a distributed system."),(0,s.kt)("li",{parentName:"ul"},"Shared database or common dependencies between services."),(0,s.kt)("li",{parentName:"ul"},"Lack of Business Alignment."),(0,s.kt)("li",{parentName:"ul"},"Lack of clear ownership."),(0,s.kt)("li",{parentName:"ul"},"Lack of idempotency."),(0,s.kt)("li",{parentName:"ul"},"Trying to do everything ",(0,s.kt)("a",{parentName:"li",href:"https://karanpratapsingh.com/courses/system-design/acid-and-base-consistency-models"},"ACID instead of BASE"),"."),(0,s.kt)("li",{parentName:"ul"},"Lack of design for fault tolerance may result in cascading failures.")),(0,s.kt)("h3",{id:"beware-of-the-distributed-monolith"},"Beware of the distributed monolith"),(0,s.kt)("p",null,"Distributed Monolith is a system that resembles the microservices architecture but is tightly coupled within itself like a monolithic application. Adopting microservices architecture comes with a lot of advantages. But while making one, there are good chances that we might end up with a distributed monolith."),(0,s.kt)("p",null,"Our microservices are just a distributed monolith if any of these apply to it:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Requires low latency communication."),(0,s.kt)("li",{parentName:"ul"},"Services don't scale easily."),(0,s.kt)("li",{parentName:"ul"},"Dependency between services."),(0,s.kt)("li",{parentName:"ul"},"Sharing the same resources such as databases."),(0,s.kt)("li",{parentName:"ul"},"Tightly coupled systems.")),(0,s.kt)("p",null,"One of the primary reasons to build an application using microservices architecture is to have scalability. Therefore, microservices should have loosely coupled services which enable every service to be independent. The distributed monolith architecture takes this away and causes most components to depend on one another, increasing design complexity."),(0,s.kt)("h3",{id:"microservices-vs-service-oriented-architecture-soa"},"Microservices vs Service-oriented architecture (SOA)"),(0,s.kt)("p",null,"You might have seen ",(0,s.kt)("em",{parentName:"p"},"Service-oriented architecture (SOA)")," mentioned around the internet, sometimes even interchangeably with microservices, but they are different from each other and the main distinction between the two approaches comes down to ",(0,s.kt)("em",{parentName:"p"},"scope"),"."),(0,s.kt)("p",null,"Service-oriented architecture (SOA) defines a way to make software components reusable via service interfaces. These interfaces utilize common communication standards and focus on maximizing application service reusability whereas microservices are built as a collection of various smallest independent service units focused on team autonomy and decoupling."),(0,s.kt)("h3",{id:"why-you-dont-need-microservices"},"Why you don't need microservices"),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/monoliths-microservices/architecture-range.png",alt:"architecture-range"})),(0,s.kt)("p",null,"So, you might be wondering, monoliths seem like a bad idea to begin with, why would anyone use that?"),(0,s.kt)("p",null,"Well, it depends. While each approach has its own advantages and disadvantages, it is advised to start with a monolith when building a new system. It is important to understand, that microservices are not a silver bullet, instead, they solve an organizational problem. Microservices architecture is about your organizational priorities and team as much as it's about technology."),(0,s.kt)("p",null,"Before making the decision to move to microservices architecture, you need to ask yourself questions like:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},'"Is the team too large to work effectively on a shared codebase?"')),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},'"Are teams blocked on other teams?"')),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},'"Does microservices deliver clear business value for us?"')),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},'"Is my business mature enough to use microservices?"')),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},'"Is our current architecture limiting us with communication overhead?"'))),(0,s.kt)("p",null,"If your application does not require to be broken down into microservices, you don't need this. There is no absolute necessity that all applications should be broken down into microservices."),(0,s.kt)("p",null,"We frequently draw inspiration from companies such as Netflix and their use of microservices, but we overlook the fact that we are not Netflix. They went through a lot of iterations and models before they had a market-ready solution, and this architecture became acceptable for them when they identified and solved the problem they were trying to tackle."),(0,s.kt)("p",null,"That's why it's essential to understand in-depth if your business ",(0,s.kt)("em",{parentName:"p"},"actually")," needs microservices. What I'm trying to say is microservices are solutions to complex concerns and if your business doesn't have complex issues, you don't need them."),(0,s.kt)("h2",{id:"event-driven-architecture-eda"},"Event-Driven Architecture (EDA)"),(0,s.kt)("p",null,"Event-Driven Architecture (EDA) is about using events as a way to communicate within a system. Generally, leveraging a message broker to publish and consume events asynchronously. The publisher is unaware of who is consuming an event and the consumers are unaware of each other. Event-Driven Architecture is simply a way of achieving loose coupling between services within a system."),(0,s.kt)("h3",{id:"what-is-an-event"},"What is an event?"),(0,s.kt)("p",null,"An event is a data point that represents state changes in a system. It doesn't specify what should happen and how the change should modify the system, it only notifies the system of a particular state change. When a user makes an action, they trigger an event."),(0,s.kt)("h3",{id:"components"},"Components"),(0,s.kt)("p",null,"Event-driven architectures have three key components:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Event producers"),": Publishes an event to the router."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Event routers"),": Filters and pushes the events to consumers."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Event consumers"),": Uses events to reflect changes in the system.")),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/event-driven-architecture/event-driven-architecture.png",alt:"event-driven-architecture"})),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Note: Dots in the diagram represents different events in the system.")),(0,s.kt)("h3",{id:"patterns"},"Patterns"),(0,s.kt)("p",null,"There are several ways to implement the event-driven architecture, and which method we use depends on the use case but here are some common examples:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://karanpratapsingh.com/courses/system-design/distributed-transactions#sagas"},"Sagas")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://karanpratapsingh.com/courses/system-design/publish-subscribe"},"Publish-Subscribe")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://karanpratapsingh.com/courses/system-design/event-sourcing"},"Event Sourcing")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://karanpratapsingh.com/courses/system-design/command-and-query-responsibility-segregation"},"Command and Query Responsibility Segregation (CQRS)"))),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Note: Each of these methods is discussed separately.")),(0,s.kt)("h3",{id:"advantages-6"},"Advantages"),(0,s.kt)("p",null,"Let's discuss some advantages:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Decoupled producers and consumers."),(0,s.kt)("li",{parentName:"ul"},"Highly scalable and distributed."),(0,s.kt)("li",{parentName:"ul"},"Easy to add new consumers."),(0,s.kt)("li",{parentName:"ul"},"Improves agility.")),(0,s.kt)("h3",{id:"challenges"},"Challenges"),(0,s.kt)("p",null,"Here are some challenges of event-drive architecture:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Guaranteed delivery."),(0,s.kt)("li",{parentName:"ul"},"Error handling is difficult."),(0,s.kt)("li",{parentName:"ul"},"Event-driven systems are complex in general."),(0,s.kt)("li",{parentName:"ul"},"Exactly once, in-order processing of events.")),(0,s.kt)("h3",{id:"use-cases"},"Use cases"),(0,s.kt)("p",null,"Below are some common use cases where event-driven architectures are beneficial:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Metadata and metrics."),(0,s.kt)("li",{parentName:"ul"},"Server and security logs."),(0,s.kt)("li",{parentName:"ul"},"Integrating heterogeneous systems."),(0,s.kt)("li",{parentName:"ul"},"Fanout and parallel processing.")),(0,s.kt)("h3",{id:"examples-4"},"Examples"),(0,s.kt)("p",null,"Here are some widely used technologies for implementing event-driven architectures:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://nats.io"},"NATS")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://kafka.apache.org"},"Apache Kafka")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://aws.amazon.com/eventbridge"},"Amazon EventBridge")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://aws.amazon.com/sns"},"Amazon SNS")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://cloud.google.com/pubsub"},"Google PubSub"))),(0,s.kt)("h2",{id:"event-sourcing"},"Event Sourcing"),(0,s.kt)("p",null,"Instead of storing just the current state of the data in a domain, use an append-only store to record the full series of actions taken on that data. The store acts as the system of record and can be used to materialize the domain objects."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/event-sourcing/event-sourcing.png",alt:"event-sourcing"})),(0,s.kt)("p",null,"This can simplify tasks in complex domains, by avoiding the need to synchronize the data model and the business domain, while improving performance, scalability, and responsiveness. It can also provide consistency for transactional data, and maintain full audit trails and history that can enable compensating actions."),(0,s.kt)("h3",{id:"event-sourcing-vs-event-driven-architecture-eda"},"Event sourcing vs Event-Driven Architecture (EDA)"),(0,s.kt)("p",null,"Event sourcing is seemingly constantly being confused with ",(0,s.kt)("a",{parentName:"p",href:"https://karanpratapsingh.com/courses/system-design/event-driven-architecture"},"Event-driven Architecture (EDA)"),". Event-driven architecture is about using events to communicate between service boundaries. Generally, leveraging a message broker to publish and consume events asynchronously within other boundaries."),(0,s.kt)("p",null,"Whereas, event sourcing is about using events as a state, which is a different approach to storing data. Rather than storing the current state, we're instead going to be storing events. Also, event sourcing is one of the several patterns to implement an event-driven architecture."),(0,s.kt)("h3",{id:"advantages-7"},"Advantages"),(0,s.kt)("p",null,"Let's discuss some advantages of using event sourcing:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Excellent for real-time data reporting."),(0,s.kt)("li",{parentName:"ul"},"Great for fail-safety, data can be reconstituted from the event store."),(0,s.kt)("li",{parentName:"ul"},"Extremely flexible, any type of message can be stored."),(0,s.kt)("li",{parentName:"ul"},"Preferred way of achieving audit logs functionality for high compliance systems.")),(0,s.kt)("h3",{id:"disadvantages-4"},"Disadvantages"),(0,s.kt)("p",null,"Following are the disadvantages of event sourcing:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Requires an extremely efficient network infrastructure."),(0,s.kt)("li",{parentName:"ul"},"Requires a reliable way to control message formats, such as a schema registry."),(0,s.kt)("li",{parentName:"ul"},"Different events will contain different payloads.")),(0,s.kt)("h2",{id:"command-and-query-responsibility-segregation-cqrs"},"Command and Query Responsibility Segregation (CQRS)"),(0,s.kt)("p",null,"Command Query Responsibility Segregation (CQRS) is an architectural pattern that divides a system's actions into commands and queries. It was first described by ",(0,s.kt)("a",{parentName:"p",href:"https://twitter.com/gregyoung"},"Greg Young"),"."),(0,s.kt)("p",null,"In CQRS, a ",(0,s.kt)("em",{parentName:"p"},"command")," is an instruction, a directive to perform a specific task. It is an intention to change something and doesn't return a value, only an indication of success or failure. And, a ",(0,s.kt)("em",{parentName:"p"},"query")," is a request for information that doesn't change the system's state or cause any side effects."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/command-and-query-responsibility-segregation/command-and-query-responsibility-segregation.png",alt:"command-and-query-responsibility-segregation"})),(0,s.kt)("p",null,"The core principle of CQRS is the separation of commands and queries. They perform fundamentally different roles within a system, and separating them means that each can be optimized as needed, which distributed systems can really benefit from."),(0,s.kt)("h3",{id:"cqrs-with-event-sourcing"},"CQRS with Event Sourcing"),(0,s.kt)("p",null,"The CQRS pattern is often used along with the Event Sourcing pattern. CQRS-based systems use separate read and write data models, each tailored to relevant tasks and often located in physically separate stores."),(0,s.kt)("p",null,"When used with the Event Sourcing pattern, the store of events is the write model and is the official source of information. The read model of a CQRS-based system provides materialized views of the data, typically as highly denormalized views."),(0,s.kt)("h3",{id:"advantages-8"},"Advantages"),(0,s.kt)("p",null,"Let's discuss some advantages of CQRS:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Allows independent scaling of read and write workloads."),(0,s.kt)("li",{parentName:"ul"},"Easier scaling, optimizations, and architectural changes."),(0,s.kt)("li",{parentName:"ul"},"Closer to business logic with loose coupling."),(0,s.kt)("li",{parentName:"ul"},"The application can avoid complex joins when querying."),(0,s.kt)("li",{parentName:"ul"},"Clear boundaries between the system behavior.")),(0,s.kt)("h3",{id:"disadvantages-5"},"Disadvantages"),(0,s.kt)("p",null,"Below are some disadvantages of CQRS:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"More complex application design."),(0,s.kt)("li",{parentName:"ul"},"Message failures or duplicate messages can occur."),(0,s.kt)("li",{parentName:"ul"},"Dealing with eventual consistency is a challenge."),(0,s.kt)("li",{parentName:"ul"},"Increased system maintenance efforts.")),(0,s.kt)("h3",{id:"use-cases-1"},"Use cases"),(0,s.kt)("p",null,"Here are some scenarios where CQRS will be helpful:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The performance of data reads must be fine-tuned separately from the performance of data writes."),(0,s.kt)("li",{parentName:"ul"},"The system is expected to evolve over time and might contain multiple versions of the model, or where business rules change regularly."),(0,s.kt)("li",{parentName:"ul"},"Integration with other systems, especially in combination with event sourcing, where the temporal failure of one subsystem shouldn't affect the availability of the others."),(0,s.kt)("li",{parentName:"ul"},"Better security to ensure that only the right domain entities are performing writes on the data.")),(0,s.kt)("h2",{id:"api-gateway"},"API Gateway"),(0,s.kt)("p",null,"The API Gateway is an API management tool that sits between a client and a collection of backend services. It is a single entry point into a system that encapsulates the internal system architecture and provides an API that is tailored to each client. It also has other responsibilities such as authentication, monitoring, load balancing, caching, throttling, logging, etc."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/api-gateway/api-gateway.png",alt:"api-gateway"})),(0,s.kt)("h3",{id:"why-do-we-need-an-api-gateway"},"Why do we need an API Gateway?"),(0,s.kt)("p",null,"The granularity of APIs provided by microservices is often different than what a client needs. Microservices typically provide fine-grained APIs, which means that clients need to interact with multiple services. Hence, an API gateway can provide a single entry point for all clients with some additional features and better management."),(0,s.kt)("h3",{id:"features-2"},"Features"),(0,s.kt)("p",null,"Below are some desired features of an API Gateway:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Authentication and Authorization"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://karanpratapsingh.com/courses/system-design/service-discovery"},"Service discovery")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://karanpratapsingh.com/courses/system-design/proxy#reverse-proxy"},"Reverse Proxy")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://karanpratapsingh.com/courses/system-design/caching"},"Caching")),(0,s.kt)("li",{parentName:"ul"},"Security"),(0,s.kt)("li",{parentName:"ul"},"Retry and ",(0,s.kt)("a",{parentName:"li",href:"https://karanpratapsingh.com/courses/system-design/circuit-breaker"},"Circuit breaking")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://karanpratapsingh.com/courses/system-design/load-balancing"},"Load balancing")),(0,s.kt)("li",{parentName:"ul"},"Logging, Tracing"),(0,s.kt)("li",{parentName:"ul"},"API composition"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://karanpratapsingh.com/courses/system-design/rate-limiting"},"Rate limiting")," and throttling"),(0,s.kt)("li",{parentName:"ul"},"Versioning"),(0,s.kt)("li",{parentName:"ul"},"Routing"),(0,s.kt)("li",{parentName:"ul"},"IP whitelisting or blacklisting")),(0,s.kt)("h3",{id:"advantages-9"},"Advantages"),(0,s.kt)("p",null,"Let's look at some advantages of using an API Gateway:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Encapsulates the internal structure of an API."),(0,s.kt)("li",{parentName:"ul"},"Provides a centralized view of the API."),(0,s.kt)("li",{parentName:"ul"},"Simplifies the client code."),(0,s.kt)("li",{parentName:"ul"},"Monitoring, analytics, tracing, and other such features.")),(0,s.kt)("h3",{id:"disadvantages-6"},"Disadvantages"),(0,s.kt)("p",null,"Here are some possible disadvantages of an API Gateway:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Possible single point of failure."),(0,s.kt)("li",{parentName:"ul"},"Might impact performance."),(0,s.kt)("li",{parentName:"ul"},"Can become a bottleneck if not scaled properly."),(0,s.kt)("li",{parentName:"ul"},"Configuration can be challenging.")),(0,s.kt)("h3",{id:"backend-for-frontend-bff-pattern"},"Backend For Frontend (BFF) pattern"),(0,s.kt)("p",null,"In the Backend For Frontend (BFF) pattern, we create separate backend services to be consumed by specific frontend applications or interfaces. This pattern is useful when we want to avoid customizing a single backend for multiple interfaces. This pattern was first described by ",(0,s.kt)("a",{parentName:"p",href:"https://samnewman.io"},"Sam Newman"),"."),(0,s.kt)("p",null,"Also, sometimes the output of data returned by the microservices to the front end is not in the exact format or filtered as needed by the front end. To solve this issue, the frontend should have some logic to reformat the data, and therefore, we can use BFF to shift some of this logic to the intermediate layer."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/api-gateway/backend-for-frontend.png",alt:"backend-for-frontend"})),(0,s.kt)("p",null,"The primary function of the backend for the frontend pattern is to get the required data from the appropriate service, format the data, and sent it to the frontend."),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},(0,s.kt)("a",{parentName:"em",href:"https://karanpratapsingh.com/courses/system-design/rest-graphql-grpc#graphql"},"GraphQL")," performs really well as a backend for frontend (BFF).")),(0,s.kt)("h4",{id:"when-to-use-this-pattern"},"When to use this pattern?"),(0,s.kt)("p",null,"We should consider using a Backend For Frontend (BFF) pattern when:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A shared or general purpose backend service must be maintained with significant development overhead."),(0,s.kt)("li",{parentName:"ul"},"We want to optimize the backend for the requirements of a specific client."),(0,s.kt)("li",{parentName:"ul"},"Customizations are made to a general-purpose backend to accommodate multiple interfaces.")),(0,s.kt)("h3",{id:"examples-5"},"Examples"),(0,s.kt)("p",null,"Following are some widely used gateways technologies:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://aws.amazon.com/api-gateway"},"Amazon API Gateway")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://cloud.google.com/apigee"},"Apigee API Gateway")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://azure.microsoft.com/en-in/services/api-management"},"Azure API Gateway")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://konghq.com/kong"},"Kong API Gateway"))),(0,s.kt)("h2",{id:"rest-graphql-grpc"},"REST, GraphQL, gRPC"),(0,s.kt)("p",null,"A good API design is always a crucial part of any system. But it is also important to pick the right API technology. So, in this tutorial, we will briefly discuss different API technologies such as REST, GraphQL, and gRPC."),(0,s.kt)("h3",{id:"whats-an-api"},"What's an API?"),(0,s.kt)("p",null,"Before we even get into API technologies, let's first understand what is an API."),(0,s.kt)("p",null,"API stands for Application Programming Interface. It is a set of definitions and protocols for building and integrating application software. It's sometimes referred to as a contract between an information provider and an information user establishing the content required from the producer and the content required by the consumer."),(0,s.kt)("p",null,"In other words, if you want to interact with a computer or system to retrieve information or perform a function, an API helps you communicate what you want to that system so it can understand and complete the request."),(0,s.kt)("h3",{id:"rest"},"REST"),(0,s.kt)("p",null,"A ",(0,s.kt)("a",{parentName:"p",href:"https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm"},"REST API")," (also known as RESTful API) is an application programming interface that conforms to the constraints of REST architectural style and allows for interaction with RESTful web services. REST stands for Representational State Transfer and it was first introduced by ",(0,s.kt)("a",{parentName:"p",href:"https://roy.gbiv.com"},"Roy Fielding")," in the year 2000."),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"In REST API, the fundamental unit is a resource.")),(0,s.kt)("h4",{id:"concepts"},"Concepts"),(0,s.kt)("p",null,"Let's discuss some concepts of a RESTful API."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Constraints")),(0,s.kt)("p",null,"In order for an API to be considered ",(0,s.kt)("em",{parentName:"p"},"RESTful"),", it has to conform to these architectural constraints:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Uniform Interface"),": There should be a uniform way of interacting with a given server."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Client-Server"),": A client-server architecture managed through HTTP."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Stateless"),": No client context shall be stored on the server between requests."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Cacheable"),": Every response should include whether the response is cacheable or not and for how much duration responses can be cached at the client-side."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Layered system"),": An application architecture needs to be composed of multiple layers."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Code on demand"),": Return executable code to support a part of your application. ",(0,s.kt)("em",{parentName:"li"},"(optional)"))),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"HTTP Verbs")),(0,s.kt)("p",null,"HTTP defines a set of request methods to indicate the desired action to be performed for a given resource. Although they can also be nouns, these request methods are sometimes referred to as ",(0,s.kt)("em",{parentName:"p"},"HTTP verbs"),". Each of them implements a different semantic, but some common features are shared by a group of them."),(0,s.kt)("p",null,"Below are some commonly used HTTP verbs:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"GET"),": Request a representation of the specified resource."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"HEAD"),": Response is identical to a ",(0,s.kt)("inlineCode",{parentName:"li"},"GET")," request, but without the response body."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"POST"),": Submits an entity to the specified resource, often causing a change in state or side effects on the server."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"PUT"),": Replaces all current representations of the target resource with the request payload."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"DELETE"),": Deletes the specified resource."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"PATCH"),": Applies partial modifications to a resource.")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"HTTP response codes")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/List_of_HTTP_status_codes"},"HTTP response status codes")," indicate whether a specific HTTP request has been successfully completed."),(0,s.kt)("p",null,"There are five classes defined by the standard:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"1xx - Informational responses."),(0,s.kt)("li",{parentName:"ul"},"2xx - Successful responses."),(0,s.kt)("li",{parentName:"ul"},"3xx - Redirection responses."),(0,s.kt)("li",{parentName:"ul"},"4xx - Client error responses."),(0,s.kt)("li",{parentName:"ul"},"5xx - Server error responses.")),(0,s.kt)("p",null,"For example, HTTP 200 means that the request was successful."),(0,s.kt)("h4",{id:"advantages-10"},"Advantages"),(0,s.kt)("p",null,"Let's discuss some advantages of REST API:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Simple and easy to understand."),(0,s.kt)("li",{parentName:"ul"},"Flexible and portable."),(0,s.kt)("li",{parentName:"ul"},"Good caching support."),(0,s.kt)("li",{parentName:"ul"},"Client and server are decoupled.")),(0,s.kt)("h4",{id:"disadvantages-7"},"Disadvantages"),(0,s.kt)("p",null,"Let's discuss some disadvantages of REST API:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Over-fetching of data."),(0,s.kt)("li",{parentName:"ul"},"Sometimes multiple round trips to the server are required.")),(0,s.kt)("h4",{id:"use-cases-2"},"Use cases"),(0,s.kt)("p",null,"REST APIs are pretty much used universally and are the default standard for designing APIs. Overall REST APIs are quite flexible and can fit almost all scenarios."),(0,s.kt)("h4",{id:"example"},"Example"),(0,s.kt)("p",null,"Here's an example usage of a REST API that operates on a ",(0,s.kt)("strong",{parentName:"p"},"users")," resource."),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"URI"),(0,s.kt)("th",{parentName:"tr",align:null},"HTTP verb"),(0,s.kt)("th",{parentName:"tr",align:null},"Description"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"/users"),(0,s.kt)("td",{parentName:"tr",align:null},"GET"),(0,s.kt)("td",{parentName:"tr",align:null},"Get all users")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"/users/","{","id","}"),(0,s.kt)("td",{parentName:"tr",align:null},"GET"),(0,s.kt)("td",{parentName:"tr",align:null},"Get a user by id")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"/users"),(0,s.kt)("td",{parentName:"tr",align:null},"POST"),(0,s.kt)("td",{parentName:"tr",align:null},"Add a new user")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"/users/","{","id","}"),(0,s.kt)("td",{parentName:"tr",align:null},"PATCH"),(0,s.kt)("td",{parentName:"tr",align:null},"Update a user by id")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"/users/","{","id","}"),(0,s.kt)("td",{parentName:"tr",align:null},"DELETE"),(0,s.kt)("td",{parentName:"tr",align:null},"Delete a user by id")))),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"There is so much more to learn when it comes to REST APIs, I will highly recommend looking into ",(0,s.kt)("a",{parentName:"em",href:"https://en.wikipedia.org/wiki/HATEOAS"},"Hypermedia as the Engine of Application State (HATEOAS)"),".")),(0,s.kt)("h3",{id:"graphql"},"GraphQL"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://graphql.org"},"GraphQL")," is a query language and server-side runtime for APIs that prioritizes giving clients exactly the data they request and no more. It was developed by ",(0,s.kt)("a",{parentName:"p",href:"https://engineering.fb.com"},"Facebook")," and later open-sourced in 2015."),(0,s.kt)("p",null,"GraphQL is designed to make APIs fast, flexible, and developer-friendly. Additionally, GraphQL gives API maintainers the flexibility to add or deprecate fields without impacting existing queries. Developers can build APIs with whatever methods they prefer, and the GraphQL specification will ensure they function in predictable ways to clients."),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"In GraphQL, the fundamental unit is a query.")),(0,s.kt)("h4",{id:"concepts-1"},"Concepts"),(0,s.kt)("p",null,"Let's briefly discuss some key concepts in GraphQL:"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Schema")),(0,s.kt)("p",null,"A GraphQL schema describes the functionality clients can utilize once they connect to the GraphQL server."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Queries")),(0,s.kt)("p",null,"A query is a request made by the client. It can consist of fields and arguments for the query. The operation type of a query can also be a ",(0,s.kt)("a",{parentName:"p",href:"https://graphql.org/learn/queries/#mutations"},"mutation")," which provides a way to modify server-side data."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Resolvers")),(0,s.kt)("p",null,"Resolver is a collection of functions that generate responses for a GraphQL query. In simple terms, a resolver acts as a GraphQL query handler."),(0,s.kt)("h4",{id:"advantages-11"},"Advantages"),(0,s.kt)("p",null,"Let's discuss some advantages of GraphQL:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Eliminates over-fetching of data."),(0,s.kt)("li",{parentName:"ul"},"Strongly defined schema."),(0,s.kt)("li",{parentName:"ul"},"Code generation support."),(0,s.kt)("li",{parentName:"ul"},"Payload optimization.")),(0,s.kt)("h4",{id:"disadvantages-8"},"Disadvantages"),(0,s.kt)("p",null,"Let's discuss some disadvantages of GraphQL:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Shifts complexity to server-side."),(0,s.kt)("li",{parentName:"ul"},"Caching becomes hard."),(0,s.kt)("li",{parentName:"ul"},"Versioning is ambiguous."),(0,s.kt)("li",{parentName:"ul"},"N+1 problem.")),(0,s.kt)("h4",{id:"use-cases-3"},"Use cases"),(0,s.kt)("p",null,"GraphQL proves to be essential in the following scenarios:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Reducing app bandwidth usage as we can query multiple resources in a single query."),(0,s.kt)("li",{parentName:"ul"},"Rapid prototyping for complex systems."),(0,s.kt)("li",{parentName:"ul"},"When we are working with a graph-like data model.")),(0,s.kt)("h4",{id:"example-1"},"Example"),(0,s.kt)("p",null,"Here's a GraphQL schema that defines a ",(0,s.kt)("inlineCode",{parentName:"p"},"User")," type and a ",(0,s.kt)("inlineCode",{parentName:"p"},"Query")," type."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  getUser: User\n}\n\ntype User {\n  id: ID\n  name: String\n  city: String\n  state: String\n}\n")),(0,s.kt)("p",null,"Using the above schema, the client can request the required fields easily without having to fetch the entire resource or guess what the API might return."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  getUser {\n    id\n    name\n    city\n  }\n}\n")),(0,s.kt)("p",null,"This will give the following response to the client."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "getUser": {\n    "id": 123,\n    "name": "Karan",\n    "city": "San Francisco"\n  }\n}\n')),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Learn more about GraphQL at ",(0,s.kt)("a",{parentName:"em",href:"https://graphql.org"},"graphql.org"),".")),(0,s.kt)("h3",{id:"grpc"},"gRPC"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://grpc.io"},"gRPC")," is a modern open-source high-performance ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Remote_procedure_call"},"Remote Procedure Call (RPC)")," framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking, authentication and much more."),(0,s.kt)("h4",{id:"concepts-2"},"Concepts"),(0,s.kt)("p",null,"Let's discuss some key concepts of gRPC."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Protocol buffers")),(0,s.kt)("p",null,"Protocol buffers provide a language and platform-neutral extensible mechanism for serializing structured data in a forward and backward-compatible way. It's like JSON, except it's smaller and faster, and it generates native language bindings."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Service definition")),(0,s.kt)("p",null,"Like many RPC systems, gRPC is based on the idea of defining a service and specifying the methods that can be called remotely with their parameters and return types. gRPC uses protocol buffers as the ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Interface_description_language"},"Interface Definition Language (IDL)")," for describing both the service interface and the structure of the payload messages."),(0,s.kt)("h4",{id:"advantages-12"},"Advantages"),(0,s.kt)("p",null,"Let's discuss some advantages of gRPC:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Lightweight and efficient."),(0,s.kt)("li",{parentName:"ul"},"High performance."),(0,s.kt)("li",{parentName:"ul"},"Built-in code generation support."),(0,s.kt)("li",{parentName:"ul"},"Bi-directional streaming.")),(0,s.kt)("h4",{id:"disadvantages-9"},"Disadvantages"),(0,s.kt)("p",null,"Let's discuss some disadvantages of gRPC:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Relatively new compared to REST and GraphQL."),(0,s.kt)("li",{parentName:"ul"},"Limited browser support."),(0,s.kt)("li",{parentName:"ul"},"Steeper learning curve."),(0,s.kt)("li",{parentName:"ul"},"Not human readable.")),(0,s.kt)("h4",{id:"use-cases-4"},"Use cases"),(0,s.kt)("p",null,"Below are some good use cases for gRPC:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Real-time communication via bi-directional streaming."),(0,s.kt)("li",{parentName:"ul"},"Efficient inter-service communication in microservices."),(0,s.kt)("li",{parentName:"ul"},"Low latency and high throughput communication."),(0,s.kt)("li",{parentName:"ul"},"Polyglot environments.")),(0,s.kt)("h4",{id:"example-2"},"Example"),(0,s.kt)("p",null,"Here's a basic example of a gRPC service defined in a ",(0,s.kt)("inlineCode",{parentName:"p"},"*.proto")," file. Using this definition, we can easily code generate the ",(0,s.kt)("inlineCode",{parentName:"p"},"HelloService")," service in the programming language of our choice."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-protobuf"},"service HelloService {\n  rpc SayHello (HelloRequest) returns (HelloResponse);\n}\n\nmessage HelloRequest {\n  string greeting = 1;\n}\n\nmessage HelloResponse {\n  string reply = 1;\n}\n")),(0,s.kt)("h3",{id:"rest-vs-graphql-vs-grpc"},"REST vs GraphQL vs gRPC"),(0,s.kt)("p",null,"Now that we know how these API designing techniques work, let's compare them based on the following parameters:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Will it cause tight coupling?"),(0,s.kt)("li",{parentName:"ul"},"How ",(0,s.kt)("em",{parentName:"li"},"chatty")," (distinct API calls to get needed information) are the APIs?"),(0,s.kt)("li",{parentName:"ul"},"What's the performance like?"),(0,s.kt)("li",{parentName:"ul"},"How complex is it to integrate?"),(0,s.kt)("li",{parentName:"ul"},"How well does the caching work?"),(0,s.kt)("li",{parentName:"ul"},"Built-in tooling and code generation?"),(0,s.kt)("li",{parentName:"ul"},"What's API discoverability like?"),(0,s.kt)("li",{parentName:"ul"},"How easy is it to version APIs?")),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Type"),(0,s.kt)("th",{parentName:"tr",align:null},"Coupling"),(0,s.kt)("th",{parentName:"tr",align:null},"Chattiness"),(0,s.kt)("th",{parentName:"tr",align:null},"Performance"),(0,s.kt)("th",{parentName:"tr",align:null},"Complexity"),(0,s.kt)("th",{parentName:"tr",align:null},"Caching"),(0,s.kt)("th",{parentName:"tr",align:null},"Codegen"),(0,s.kt)("th",{parentName:"tr",align:null},"Discoverability"),(0,s.kt)("th",{parentName:"tr",align:null},"Versioning"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"REST"),(0,s.kt)("td",{parentName:"tr",align:null},"Low"),(0,s.kt)("td",{parentName:"tr",align:null},"High"),(0,s.kt)("td",{parentName:"tr",align:null},"Good"),(0,s.kt)("td",{parentName:"tr",align:null},"Medium"),(0,s.kt)("td",{parentName:"tr",align:null},"Great"),(0,s.kt)("td",{parentName:"tr",align:null},"Bad"),(0,s.kt)("td",{parentName:"tr",align:null},"Good"),(0,s.kt)("td",{parentName:"tr",align:null},"Easy")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"GraphQL"),(0,s.kt)("td",{parentName:"tr",align:null},"Medium"),(0,s.kt)("td",{parentName:"tr",align:null},"Low"),(0,s.kt)("td",{parentName:"tr",align:null},"Good"),(0,s.kt)("td",{parentName:"tr",align:null},"High"),(0,s.kt)("td",{parentName:"tr",align:null},"Custom"),(0,s.kt)("td",{parentName:"tr",align:null},"Good"),(0,s.kt)("td",{parentName:"tr",align:null},"Good"),(0,s.kt)("td",{parentName:"tr",align:null},"Custom")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,s.kt)("td",{parentName:"tr",align:null},"High"),(0,s.kt)("td",{parentName:"tr",align:null},"Medium"),(0,s.kt)("td",{parentName:"tr",align:null},"Great"),(0,s.kt)("td",{parentName:"tr",align:null},"Low"),(0,s.kt)("td",{parentName:"tr",align:null},"Custom"),(0,s.kt)("td",{parentName:"tr",align:null},"Great"),(0,s.kt)("td",{parentName:"tr",align:null},"Bad"),(0,s.kt)("td",{parentName:"tr",align:null},"Hard")))),(0,s.kt)("h4",{id:"which-api-technology-is-better"},"Which API technology is better?"),(0,s.kt)("p",null,"Well, the answer is none of them. There is no silver bullet as each of these technologies has its own advantages and disadvantages. Users only care about using our APIs in a consistent way, so make sure to focus on your domain and requirements when designing your API."),(0,s.kt)("h2",{id:"long-polling-websockets-server-sent-events-sse"},"Long polling, WebSockets, Server-Sent Events (SSE)"),(0,s.kt)("p",null,"Web applications were initially developed around a client-server model, where the web client is always the initiator of transactions like requesting data from the server. Thus, there was no mechanism for the server to independently send, or push, data to the client without the client first making a request. Let's discuss some approaches to overcome this problem."),(0,s.kt)("h3",{id:"long-polling"},"Long polling"),(0,s.kt)("p",null,"HTTP Long polling is a technique used to push information to a client as soon as possible from the server. As a result, the server does not have to wait for the client to send a request."),(0,s.kt)("p",null,"In Long polling, the server does not close the connection once it receives a request from the client. Instead, the server responds only if any new message is available or a timeout threshold is reached."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/long-polling-websockets-server-sent-events/long-polling.png",alt:"long-polling"})),(0,s.kt)("p",null,"Once the client receives a response, it immediately sends a new request to the server to have a new pending connection to send data to the client, and the operation is repeated. With this approach, the server emulates a real-time server push feature."),(0,s.kt)("h4",{id:"working-2"},"Working"),(0,s.kt)("p",null,"Let's understand how long polling works:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"The client makes an initial request and waits for a response."),(0,s.kt)("li",{parentName:"ol"},"The server receives the request and delays sending anything until an update is available."),(0,s.kt)("li",{parentName:"ol"},"Once an update is available, the response is sent to the client."),(0,s.kt)("li",{parentName:"ol"},"The client receives the response and makes a new request immediately or after some defined interval to establish a connection again.")),(0,s.kt)("h4",{id:"advantages-13"},"Advantages"),(0,s.kt)("p",null,"Here are some advantages of long polling:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Easy to implement, good for small-scale projects."),(0,s.kt)("li",{parentName:"ul"},"Nearly universally supported.")),(0,s.kt)("h4",{id:"disadvantages-10"},"Disadvantages"),(0,s.kt)("p",null,"A major downside of long polling is that it is usually not scalable. Below are some of the other reasons:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Creates a new connection each time, which can be intensive on the server."),(0,s.kt)("li",{parentName:"ul"},"Reliable message ordering can be an issue for multiple requests."),(0,s.kt)("li",{parentName:"ul"},"Increased latency as the server needs to wait for a new request.")),(0,s.kt)("h3",{id:"websockets"},"WebSockets"),(0,s.kt)("p",null,"WebSocket provides full-duplex communication channels over a single TCP connection. It is a persistent connection between a client and a server that both parties can use to start sending data at any time."),(0,s.kt)("p",null,"The client establishes a WebSocket connection through a process known as the WebSocket handshake. If the process succeeds, then the server and client can exchange data in both directions at any time. The WebSocket protocol enables the communication between a client and a server with lower overheads, facilitating real-time data transfer from and to the server."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/long-polling-websockets-server-sent-events/websockets.png",alt:"websockets"})),(0,s.kt)("p",null,"This is made possible by providing a standardized way for the server to send content to the client without being asked and allowing for messages to be passed back and forth while keeping the connection open."),(0,s.kt)("h4",{id:"working-3"},"Working"),(0,s.kt)("p",null,"Let's understand how WebSockets work:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"The client initiates a WebSocket handshake process by sending a request."),(0,s.kt)("li",{parentName:"ol"},"The request also contains an ",(0,s.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/HTTP/1.1_Upgrade_header"},"HTTP Upgrade")," header that allows the request to switch to the WebSocket protocol (",(0,s.kt)("inlineCode",{parentName:"li"},"ws://"),")."),(0,s.kt)("li",{parentName:"ol"},"The server sends a response to the client, acknowledging the WebSocket handshake request."),(0,s.kt)("li",{parentName:"ol"},"A WebSocket connection will be opened once the client receives a successful handshake response."),(0,s.kt)("li",{parentName:"ol"},"Now the client and server can start sending data in both directions allowing real-time communication."),(0,s.kt)("li",{parentName:"ol"},"The connection is closed once the server or the client decides to close the connection.")),(0,s.kt)("h4",{id:"advantages-14"},"Advantages"),(0,s.kt)("p",null,"Below are some advantages of WebSockets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Full-duplex asynchronous messaging."),(0,s.kt)("li",{parentName:"ul"},"Better origin-based security model."),(0,s.kt)("li",{parentName:"ul"},"Lightweight for both client and server.")),(0,s.kt)("h4",{id:"disadvantages-11"},"Disadvantages"),(0,s.kt)("p",null,"Let's discuss some disadvantages of WebSockets:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Terminated connections aren't automatically recovered."),(0,s.kt)("li",{parentName:"ul"},"Older browsers don't support WebSockets (becoming less relevant).")),(0,s.kt)("h3",{id:"server-sent-events-sse"},"Server-Sent Events (SSE)"),(0,s.kt)("p",null,"Server-Sent Events (SSE) is a way of establishing long-term communication between client and server that enables the server to proactively push data to the client."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-III/long-polling-websockets-server-sent-events/server-sent-events.png",alt:"server-sent-events"})),(0,s.kt)("p",null,"It is unidirectional, meaning once the client sends the request it can only receive the responses without the ability to send new requests over the same connection."),(0,s.kt)("h4",{id:"working-4"},"Working"),(0,s.kt)("p",null,"Let's understand how server-sent events work:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"The client makes a request to the server."),(0,s.kt)("li",{parentName:"ol"},"The connection between client and server is established and it remains open."),(0,s.kt)("li",{parentName:"ol"},"The server sends responses or events to the client when new data is available.")),(0,s.kt)("h4",{id:"advantages-15"},"Advantages"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Simple to implement and use for both client and server."),(0,s.kt)("li",{parentName:"ul"},"Supported by most browsers."),(0,s.kt)("li",{parentName:"ul"},"No trouble with firewalls.")),(0,s.kt)("h4",{id:"disadvantages-12"},"Disadvantages"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Unidirectional nature can be limiting."),(0,s.kt)("li",{parentName:"ul"},"Limitation for the maximum number of open connections."),(0,s.kt)("li",{parentName:"ul"},"Does not support binary data.")))}d.isMDXComponent=!0}}]);